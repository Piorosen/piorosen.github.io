<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://blog.udon.party/feed.xml" rel="self" type="application/atom+xml"/><link href="https://blog.udon.party/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-16T01:42:28+00:00</updated><id>https://blog.udon.party/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">위노그라드 알고리즘 정리</title><link href="https://blog.udon.party/blog/2025/Winograd-Algorithm/" rel="alternate" type="text/html" title="위노그라드 알고리즘 정리"/><published>2025-02-10T00:00:00+00:00</published><updated>2025-02-10T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2025/Winograd-Algorithm</id><content type="html" xml:base="https://blog.udon.party/blog/2025/Winograd-Algorithm/"><![CDATA[<h1 id="개요">개요</h1>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Review"/><category term="winograd"/><category term="algorithm"/><category term="gemm"/><category term="convolution"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">외부에서 내부망으로 접근하기 위한 3가지의 방법론</title><link href="https://blog.udon.party/blog/2024/ssh-vpn-forward/" rel="alternate" type="text/html" title="외부에서 내부망으로 접근하기 위한 3가지의 방법론"/><published>2024-11-05T00:00:00+00:00</published><updated>2024-11-05T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/ssh-vpn-forward</id><content type="html" xml:base="https://blog.udon.party/blog/2024/ssh-vpn-forward/"><![CDATA[<h1 id="개요">개요</h1> <p>본 내용은, 필자가 외부에서 내부로 접근이 되지 않는 인터넷 상황에서 접근 할 수 있는 방법에 대해서 경험을 공유하고자 한다. 일부 경우는 정말로 급하거나 위급한 상황에서만 적용하기를 바라며, 보안 위배가 될 수 도 있으므로 잘 확인해보고 사용해보길 바랍니다.</p> <p>먼저, 요약하자면, 인트라넷에 접근이 불가능한 상황에 대해서 어떻게 접근 할 수 있을까? 라는 내용으로 이야기 하고자 한다.</p> <p>(1) 인트라넷의 보안으로 인해 외부 트래픽이 잡히면 안되는 경우 (2) 인트라넷이 인터넷이 되지 않아 접근이 어려운 경우 (3) 기타 여러 상황에서 외부에서 내부로 접근을 하고 싶은 경우</p> <p>필자는 외부에서 내부로 통신하기 위해서 크게 3가지 방법을 제안하며, 따라해도 되는 것과 안되는 것에 대해서는 미리 이야기할 예정이다. (가능하다는 것과 합법이란 내용은 다르기 때문이다.)</p> <h1 id="lte-router-기반-통신">LTE Router 기반 통신</h1> <p>가장 쉬우면서 가장 이상적이지만 잘못했다간 큰 문제가 발생하는 방법 중 하나이다. LTE Router는 USB 형태로된 스틱이며 컴퓨터에 연결하게 되면 공유기/이더넷으로 인식하여 인터넷을 가능하게 만들어주는 장치이다. 스마트폰의 LTE 유심을 기반으로 통신하기 때문에 완전히 인터넷이 격리된 상황에서 인터넷이 되도록 만들어주는 매우 유용한 하드웨어이다.</p> <p>다만, 보안으로 인해 외부 통신이 격리된 상황에서 LTE Router를 통해 외부 통신을 한다는 것 자체는 상당히 위험한 생각이므로, 인터넷 케이블을 끌고 올 수 없는 상황에서 사용하길 바란다.</p> <p>물론, LTE Router만 이용해서 외부에서 내부로 들어오는 것은 여러 보안 솔루션으로 인해 관측이 될 가능성이 있기 때문에 여전히 어렵고, LTE 특성상 고정 아이피를 가질 수도 없거니와 외부에서 접근이 불가능하다.</p> <p>다만, LTE Router를 통해 문제가 외부에서 어떻게 인트라넷에 접근할까? 에서 외부에서 어떻게 LTE 서버에 접근 할 수 있을까? 로 새롭게 정의된다. 즉, 기술적으로 고정 아이피를 가질 수 없고, 인바운드가 접근이 불가능한 경우에 어떻게 하면 접근이 가능할까? 라는 문제로 귀결되므로 이제는 쉽게 문제 해결할 수 있다.</p> <p>어떻게 하면 좋을까? 만약에 바로 떠오른 방법이 있다면 이 글을 읽고 있는 사람은 매우 똑똑하거나 이미 현업자일거라 생각한다. 맞다. 바로 <code class="language-plaintext highlighter-rouge">VPN</code>을 통한다면 충분히 가상 사설망을 통해 서로 통신이 가능해진다. <code class="language-plaintext highlighter-rouge">VPN</code>은 서로 다른 인터넷을 하나의 인터넷으로 구성하는 가상 “라우터” 역할을 수행한다. 그렇기 때문에, 어딘가에 VPN 서버를 구축하고, LTE Router를 VPN 서버에 연결한다면 VPN을 경유해서 LTE 라우터와 통신이 가능해진다.</p> <p><img src="/assets/img/post/2024-11-06-01.png" alt=""/></p> <p>뭔가 잘 이해가 되지 않는다면 위의 이미지를 통해 조금 더 쉽게 이해 할 수 있다. 사용자가 VPN에 접속하고, VPN을 경유하여 LTE Router를 거쳐 Intranet에 접속한다는 의미이다. 이렇게 수행한다면? 인트라넷에서는 LTE Router라는 외부 장치를 인지하지 못하면서 외부에서 내부로 접근이 가능하다.</p> <p>물론, 항상 이야기하자면, 실제 시스템이나 회사에서 사용한다면 심각한 보안 이슈이기 때문에 적극적으로 추천하지 않으나, 이동식 개인 서버를 구축한다면 상당히 매력적인 하나의 방법론이 될 수 있다. LTE Router와 VPN을 기반으로 하는 서버 구축은 차후에 언급하도록 한다.</p> <h1 id="reverse-port-foward-on-ssh">Reverse Port Foward on SSH</h1> <p>그 다음 방법으로는 적극적인 VPN과 외부 하드웨어 도입을 통해 접근하는 방법도 있겠지만, 해당 방법은 공식적인 접근 루트가 존재할 때, 접근하는 방법에 대해서 이야기한다.</p> <p><img src="/assets/img/post/2024-11-06-02.png" alt=""/></p> <p>화살표를 유심하게 보는 것을 추천한다. 사용자와 인트라넷에서 모두 접근이 가능한 SSH 서버가 존재할 때 사용이 가능하다. 다시 말해, SSH 서버가 인트라넷 서버에 접근은 불가능하면서, 인트라넷은 접속이 가능한 SSH 서버가 존재할 때 인트라넷에 접근하는 방법을 알려주고자 한다.</p> <p>먼저 거두절미하고, 명령어 부터 설명하자면 전방 포워드와 달리 <code class="language-plaintext highlighter-rouge">-L</code>, <code class="language-plaintext highlighter-rouge">-R</code>를 이용한다. 그리고 의미도 완전히 달라지는데, SSH 서버의 포트 1234에 접근한다면, 접속자의 컴퓨터를 기준으로 <code class="language-plaintext highlighter-rouge">127.0.0.1:22</code> 로 바인딩하는 것이다.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ssh <span class="nt">-R</span> 1234:127.0.0.1:22 user@ip-address
</code></pre></div></div> <p>즉, 만약에 <code class="language-plaintext highlighter-rouge">intranet</code>에서 위의 명령어를 사용한다면, 외부 사용자가 <code class="language-plaintext highlighter-rouge">SSH Server</code>로 접속한뒤 다시 <code class="language-plaintext highlighter-rouge">ssh user@127.0.0.1 -p 1234</code> 로 인트라넷 컴퓨터에 <code class="language-plaintext highlighter-rouge">ssh</code> 접속이 가능하다는 멋진 결과를 볼 수 있다.</p> <p>물론, <code class="language-plaintext highlighter-rouge">ssh</code> 기반이므로, <code class="language-plaintext highlighter-rouge">SSH 서버</code>와 <code class="language-plaintext highlighter-rouge">Intranet</code>이 계속해서 통신하므로 인트라넷에서 보안으로 문제 삼을 수 있으므로 조심하는 것이 중요하다.</p> <h1 id="more-eassily-ssh-based-vpn">More Eassily, SSH based VPN</h1> <p>만약에 이러한 내용들이 모두 어렵다! 그냥 쉽게 쓰고 싶다! 한다면 SSH 서버를 VPN으로 사용할 수 있다! 자세한 내용은 필자가 2023년 9월 17일에 작성한 <a href="https://blog.udon.party/posts/program-review-shuttle/"><code class="language-plaintext highlighter-rouge">SSH 기반 VPN 클라이언트 sshutle(SSH Over VPN)</code></a> 내용을 확인하길 바란다.</p> <p>요약하자면, 모든 데이터를 <code class="language-plaintext highlighter-rouge">SSH Server</code>로 보내서 통신한다. 즉, 모든 포트와 모든 IP 대역폭을 전방, 역방향 포워딩을 수행한다는 의미이다. 그렇기 때문에 아무런 생각 없이, VPN 없이 인트라넷에 접속할 수 있다.</p> <h1 id="결론">결론</h1> <p>인트라넷에 접속하기 위해, LTE Router를 통한 접속, 리버스 포트포워딩을 통한 접속, SSH 기반의 VPN, 로 3가지 방법을 설명하였다.</p> <p>가장 합리적이고 인트라넷 보안에 걸리지 않는 가장 좋은 방법은 완전히 외부 독립적인 도구를 사용하는, LTE Router 방식이 안정적이다. 하지만 걸리거나 문제가 발생할 경우 가장 크게 질타를 받을 내용이기도 하다.</p> <p>다만, 인트라넷이 아닌 개인 노트북에 서버를 구축하기 위해 VPN을 사용하거나, LTE 기반의 장비를 외부에서 접근하기 위한 방도로 생각한다면 LTE Router와 VPN 조합은 매우 좋은 아이디어라고 생각한다.</p> <p>하지만, 가장 조심스럽고 합리적으로 생각한다면 리버스 포트포워딩을 통해 가능한 합법적인 통신 경로로 통신하는 것을 추천한다.</p> ]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Present"/><category term="ssh"/><category term="vpn"/><category term="proxy"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">GIST Developers’ Night 2024에 연사로 참가하고 나서</title><link href="https://blog.udon.party/blog/2024/GIST-Developer/" rel="alternate" type="text/html" title="GIST Developers’ Night 2024에 연사로 참가하고 나서"/><published>2024-10-20T00:00:00+00:00</published><updated>2024-10-20T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/GIST-Developer</id><content type="html" xml:base="https://blog.udon.party/blog/2024/GIST-Developer/"><![CDATA[<h1 id="개요">개요</h1> <p>먼저, GIST 개발자의 밤에 연사로 참여할 수 있게 되어 감사의 인사를 드립니다. 그리고 발표 자료나, 행사 사진에 관련해서는 따로 리포지토리를 생성하여 관리를 하고 있어 다운로드해서 보셔도 괜찮습니다.</p> <p><a href="https://github.com/Piorosen/2024-GIST-Developers-Night">[깃허브 리포지토리]</a></p> <p>연사로 참여하여 발표하게 된 내용은, 제가 이전에 논문을 쓰면서 알게 된 내용을 기반으로 작성하였습니다. 스마트폰에서 우분투를 올릴 수 없을까? 그리고 스마트폰은 왜 임베디드 시스템으로 역할을 할 수 있지 않을까? 라는 의문을 가지게 되었고 실증을 해본 결과 가능하다는 것을 알게 되었습니다. 이를 통해 모두, 스마트폰으로 서버를 만들 수 있다면 얼마나 서버 비용을 낮추고 배터리까지 탑재된 고 성능 서버를 얻게 될 수 있을거라 생각했습니다.</p> <p>깃허브 리포지토리에 행사 포스터와 행사 일정이 자세하게 나와 있으므로, 해당 블로그 내용에는 굳이 업로드 하지 않을 예정입니다. (깃허브의 공간의 부족의 문제와 이것 저것 문제가 이제 고려해야할 단계가 오고 있기 때문에 그렇습니다.)</p> <h1 id="table-of-content-in-post">Table of Content in Post</h1> <ol> <li>GIST Developer Ninght의 분위기와 후기</li> <li>발표 내용 요약</li> <li>본 발표를 통해 얻은 영감 및 결론</li> </ol> <h1 id="gist-developer-ninght의-분위기">GIST Developer Ninght의 분위기</h1> <p>발표 장소와 대화할 수 있는 공간이 별도로 마련이 되어 있었기 때문에, 발표를 듣고 싶은 사람과 소통을 하고 싶은 사람간에 대화 할 수 있는게 정말로 좋았다. 백엔드 부터 인프라, 회사에 다니고 있거나 창업하신 분과 대화를 개발 이란 주제로 나눌 수 있었다. 대부분 발표의 내용이 쉽운 주제로 선정이 되어있었기 때문에 많은 사람들이 들을 수 있었던 것 같다라고 생각한다.</p> <p>필자의 경우에는 <code class="language-plaintext highlighter-rouge">더 이상은 라즈베리 파이를 그만 사용하고, 우리들의 스마트폰을 이용하자.</code>란 주제로 선정한 덕분인지는 잘 모르곘지만, 많은 사람들이 관심을 가져준 것이 정말로 좋았다. 실제로, 준비한 세션에서 시연과 함께 따라 할 수 있게 만들었는데, 직접 스마트폰으로 서버를 열고 테스트를 해주신 분들이 있어 정말로 고마웠다. 그 정도로 많은 사람들이 관심과, 세션을 잘 따라와주었다.</p> <h1 id="발표-내용-요약">발표 내용 요약</h1> <p>가장 추천을 드리는 것은, 발표 PPT 또는 PDF를 다운로드 받아서, 보는것이 제일 좋다. <a href="https://github.com/Piorosen/2024-GIST-Developers-Night/raw/refs/heads/main/presentation_2024.09.28.pdf">[다운로드 PDF]</a> 그렇지만, 간단하게 요약이 필요한 독자도 있을 것이 분명하기에, 간단하게 요약을 하고자 한다.</p> <p>발표에서 전달하고 싶은 내용은 단 한가지이다. 리눅스가 설치된 시스템은 표준화된 하나의 시스템에서 동작한다는 것을 의미한다. 즉, 리눅스가 설치된 모든 시스템은 CPU만 다르다는 것이다. 그리고 모든 프로그램은 누군가가 작성한 소스코드로부터 동작한다는 것이다.</p> <p>이해가 어렵다면, 리눅스에 있는 모든 소프트웨어는 누군가가 만들어 놓은 소프트웨어라는 것을 잊지 않는다면 된다. 공유기에 올라간 운영체제 또한, 소프트웨어라는 것을 이해만 한다면, 우리는 공유기에 새로운 소프트웨어를 설치가 가능하다라는 것이다.</p> <p>이를 기반으로, 안드로이드 운영체제를 타겟으로 한 <code class="language-plaintext highlighter-rouge">Termux</code> 프로젝트가 있다. <code class="language-plaintext highlighter-rouge">Termux</code>는 <code class="language-plaintext highlighter-rouge">GCC</code>, <code class="language-plaintext highlighter-rouge">Python</code>, <code class="language-plaintext highlighter-rouge">NodeJS</code>를 빌드하여 배포하는, 일종의 패키지 매니저를 수행한다. 일부 글에서는, <code class="language-plaintext highlighter-rouge">Termux</code>를 에뮬레이터 / 시뮬레이터, 가상화 도구라고 표현이 되어있지만, 그것이 아니다. 만약 에뮬이나 시뮬레이터와 같은 존재였다면, 안드로이드의 <code class="language-plaintext highlighter-rouge">ADB</code>에서 <code class="language-plaintext highlighter-rouge">Termux</code>에서 설치한 <code class="language-plaintext highlighter-rouge">Python</code>이 실행이 되어선 안된다. 그러나 정상적으로 실행하고 동작이 가능하고, 이를 기반으로 서버 역할도 가능하다.</p> <p><code class="language-plaintext highlighter-rouge">Termux</code>와 <code class="language-plaintext highlighter-rouge">ADB</code>를 통해 안드로이드를 안드로이드가 아닌 하나의 리눅스 시스템으로 만들 수 있으며, 하나의 <code class="language-plaintext highlighter-rouge">AWS의 Graviton</code>과 같은 시스템을 만들 수 있음을 시사한다. 스마트폰에는 배터리, 고 성능 CPU, 디스플레이가 있음을 이해한다면 매우 저렴한 임베디드 보드로 충분히 활용이 가능하며, 서버로도 사용이 가능하다. 그래서, 필자는 더 이상 라즈베리파이를 그만 구매하고, 스마트폰으로 서버를 실행한다면 매우 멋진 프로젝트가 되지 않을까? 라는 생각을 하여 발표하게 되었다.</p> <h1 id="후회">후회</h1> <p>발표 자료를 준비와 발표는 큰 문제가 없었지만, 조금 더 이 주제로 대해서 미리 더 공부를 했다면 좋았었을 텐데 라는 후회가 크다. 개념을 확장해서 더 확장해서 이게 왜 가능한지, 다른 시스템에서는 가능하지 않을까? 라는 내용을 전달하지 못해 아쉽다.</p> <p>필자가, 해당 주제로 <a href="https://iemek.org/Conference/ConferenceView.asp?top_param=4&amp;sub_param=1&amp;AC=0&amp;CODE=CC20240802">(사) 임베디드 공학회 춘계 학술대회</a> 논문으로 작성하면서, 필자가 정말로 많은 부족함이 있었구나. 라는 것을 알게 되면서 후회가 정말로 컸다.</p> <p>근간이 되는 기술이 1987년의 초기 형태의 컨테이너를 기반으로 한다면, 그리고 리눅스 커널만 존재한다면 <code class="language-plaintext highlighter-rouge">어떠한 시스템</code>에서도 된다는 것을 알게되었을 때 아쉬움이 크게 다가왔다. 이후에 실험을 해본 결과, MIPS 계열(RISC-V CPU 종류 중 하나)를 탑재한 IPTime 공유기에서 우분투가 올라가고 파이썬이 설치가 된다는것 알았을 때, 얼마나 큰 공허감이 생겼겠는가. 이를 실증하고 테스트하기 위해 리포지토리를 생성하여 관리하고 있다. <a href="https://github.com/Piorosen/iptime-to-ubuntu">[Ubuntu on Router of IPTime]</a>이 얼마나 어이가 없는가. 공유기에 우분투가 올라가는 것을 테스트 해보는 것은 제 정신이 아니라면 하지 않을 것이다.</p> <p>단, 필자는 연구자이며 실험하기 위한 테스트 보드로 MIPS 계열의 CPU가 생겼다는 것은 새로운 논문의 이점이 되기도 한다. 그 어느 누가, 공유기에 탑재된 매우 초 저성능 CPU, RISC-V에 TVM이라던가, LaMMa3.2를 돌려보고 실험하고 최적화를 하겠는가. 그게 바로 필자가 된다면, 재밌을 것 같았다. 백서든, 리포트든, 필자는 재미로 움직이기 때문이다.</p>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Present"/><category term="gist"/><category term="dev-night"/><category term="presenter"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">JVM 밑바닥까지 파헤치기 책을 읽고</title><link href="https://blog.udon.party/blog/2024/jvm-book-readed/" rel="alternate" type="text/html" title="JVM 밑바닥까지 파헤치기 책을 읽고"/><published>2024-09-27T00:00:00+00:00</published><updated>2024-09-27T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/jvm-book-readed</id><content type="html" xml:base="https://blog.udon.party/blog/2024/jvm-book-readed/"><![CDATA[<h1 id="개요">개요</h1> <p>먼저, 필자가 대학원에 오기도 했으며, 입학하자 말자 너무 바쁜 일정으로 인해 글을 작성하지 못하였다. 그렇다 보니 자연스럽게 글을 쓰는 것을 미루게 되었고, 점점 더 더 많은 지식과 내용을 써야해!! 같은 압박감이 느껴지게 되었다. 우선, 지금까지 추가적으로 책을 2권을 더 읽었었고, 최근에는 논문 1일 1개 읽기 챌린지를 하고 있다. 특히, 전하고 싶은 내용은 정말로 많으나… 쓰기 위한 나의 지식이 한참 많이 부족하다! 라는 생각이 들고 있다. 거두절미하고, 대학원에 입학하자 말자, 지도 교수님에게 달려가서 연구 과제비로 구매하여 읽어본 책이였으며, 교양을 쌓기에 정말로 좋은 책이였다.</p> <p>필자는 지금 현재, <code class="language-plaintext highlighter-rouge">Memory Management Unit</code>과 DRAM 최적화에 대해 공부와, 논문거리에 쓸 내용이 정말로 무궁무진한 이기종 컴퓨팅에 관련하여 연구를 하고있다. 그래서, <code class="language-plaintext highlighter-rouge">Garbage Collect</code>에 대해서 관심과, 맨 마지막에 있는 <code class="language-plaintext highlighter-rouge">JIT</code>, <code class="language-plaintext highlighter-rouge">AOT</code>관련된 내용이 있어 읽어보면 좋은 공부가 될 것 같았고, 예상대로 좋은 책이였다.</p> <p>논문을 읽는것 보다 책을 읽는 것을 무척이나 좋아한다. 이유로는 논문은 지금 현재의 문제점과 개선방향에 대해서 집중하는 반면에, 책은 처음부터 끝까지 모든 내용에 대해 전반적으로 설명을 해주기 때문이다. 그렇기에, 궁금하고 더 자세히 알고 싶다면 그때서 기술의 근원이 되는 논문을 찾아보는 편이라서, 책을 좋아한다.</p> <h1 id="책">책</h1> <p><a href="https://product.kyobobook.co.kr/detail/S000213057051"><img src="https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9788966264414.jpg" alt=""/></a></p> <p>올해, 4월달에 나온 책을 9월에 읽는 다는건 조금 늦은감이 있긴 하다. 하지만 이 책은 3~5년이 지나더라도 읽을 사람은 분명히 많을 것이라고 필자는 생각한다. 책의 내용 자체가 현재와 미래에 대해서 이야기를 하는것이 아닌, Java의 근원부터 설명을 하며, Java 버전 1 부터 지금까지의 역사에 대한 내용이다. 그래서, 만약에 Java에 대해서 자세히 공부를 하고 싶지 않거나, <code class="language-plaintext highlighter-rouge">Spring Boot</code>의 <code class="language-plaintext highlighter-rouge">Annotation</code>이 어떻게 동작하는지 궁금하지 않거나, <code class="language-plaintext highlighter-rouge">JVM</code>이 알아서 잘해주지 않을까? 라고 생각한다면, 이 책은 필요가 없다.</p> <p><img src="/assets/img/post/2024-09-27-01.png" alt=""/></p> <p>부 제목을 보면 알듯이, <code class="language-plaintext highlighter-rouge">자동 메모리 관리</code>, <code class="language-plaintext highlighter-rouge">실행 서비스시템</code>, <code class="language-plaintext highlighter-rouge">컴파일</code>, <code class="language-plaintext highlighter-rouge">동시성</code> 이다보니, 책의 내용 대부분이 GC, GC, GC, Optimizing JAVA 에 대한 내용이다.</p> <p>아직 책이 출간된지 얼마가 되지 않았기 때문에 자세하게 설명을 하는것은 아니라고 생각하기도 하며, 직접 읽어보는걸 추천한다.</p> <p>다만, 컴퓨터 개론 공부는 최고이며 새로운 논문 거리를 만들어 준다.</p> <h1 id="내용">내용</h1> <p>책을 읽으면서, GC에 대해서 3장에 대해서 자세히 설명이 되어 있었는데, 필자가 Udemy의 인강에서 공부했던, GC 내용이 한번 더 공부하는 느낌이라서 정말로 좋았다. 특히, <code class="language-plaintext highlighter-rouge">G1</code>는 알고 있었지만, <code class="language-plaintext highlighter-rouge">ZGC</code>의 가비지 컬렉터는 상상 이상으로 아이디어가 대단한 사람이라는것을 알게해주었었다. 물론, 이 책을 읽어보지 않고, 목차만 검색하더라도 충분한 책에 대한 Insight를 경험할 수 있다라고 생각한다.</p> <pre><code class="language-txt">3.1 들어가며
3.2 대상이 죽었는가?
3.3 가비지 컬렉션 알고리즘
3.4 핫스팟 알고리즘 상세 구현
3.5 클래식 가비지 컬렉터
3.6 저지연 가비지 컬렉터
3.7 적합한 가비지 컬렉터 선택하기
3.8 실전: 메모리 할당과 회수 전략
</code></pre> <p>그 외적으로는 필자는 C/C++ 개발을 하며, 나아가 컴파일러쪽으로 연구를 하고 있다보니, Java가 어떻게 동작하는지는 읽지 않았다. (e.g. 가상 머신 성능 모니터링과 문제 해결 도구, 클래스 파일 구조, 클래스 로딩 메커니즘) 그리고, 하나의 분야에 대해서 공부를 하는 것이 아니라, 다양한 분야에 대해서 Insight를 얻는 것은 매우 좋은 것 같으며, 논문거리로 생각하기에도 좋다고 생각을 하고 있다.</p> <p>히히… 최고였다..</p>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Develop"/><category term="jvm"/><category term="memory"/><category term="jit"/><category term="aot"/><category term="garbage-collect"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">고성능을 위한 언어 C++ 책을 읽고나서</title><link href="https://blog.udon.party/blog/2024/reading-High-Performance-Cpp/" rel="alternate" type="text/html" title="고성능을 위한 언어 C++ 책을 읽고나서"/><published>2024-07-09T00:00:00+00:00</published><updated>2024-07-09T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/reading-High-Performance-Cpp</id><content type="html" xml:base="https://blog.udon.party/blog/2024/reading-High-Performance-Cpp/"><![CDATA[<h1 id="개요">개요</h1> <p>이번에 읽은 책으로는 기존에 공부하였던 내용들에 대해서 한번 더 복습하는 기회가 되었다. 그리고 C++ 20 에 대해서 한 번 공부 할 수 있는 기회였다. 아무래도, C++ 20이나 C++ 23은 책으로된 내용이 많이 부족하다 보니 좋은 기회였다. 그렇지만 다음에 이 책을 읽을 기회가 있는 새로운 독자의 경우에는 충분한 C++ 지식이나 다른 언어에 대한 선행 지식이 있어야 읽기 편할것 같다.</p> <p>무언가 C++에 대해서 깊고 심오함을 공부하고 싶다면 <code class="language-plaintext highlighter-rouge">Optimized C++</code>를 읽어보는것이 더 좋을 것이며, 이 책의 경우에는 C++ 17과 C++ 20에서 메모리 관리와 새로운 문법에 대해서 공부에 집중한 느낌이였다.</p> <p>책의 페이지가 총 450p 정도 되는 양이였고, 하루에 100p 정도 읽어서 4일만에 다 읽었기 때문에, 충분한 사전 지식이 있다면 술술 읽을 수 있을것이라 생각한다.</p> <h1 id="핵심-내용">핵심 내용</h1> <p>필자가 재밌게 읽었던 부분을 요약하자면 아래와 같고, 이름은 필자가 조금 변형하였다.</p> <ol> <li>캡처가 된다면 람다는 클래스화가 되는거였다! p76</li> <li>이동 시멘틱은 나 천재인듯! 이제야 이해하다니!! ㅠㅠ rust의 소유권 이전과 동일하구나! p100</li> <li>평행 배열이 존재할 때, 구조체의 변수의 크기가 작다면, 캐시 라인에 많은 배열이 들어가므로, 속도 개선이 된다. p158</li> <li><code class="language-plaintext highlighter-rouge">Iterator</code> 직접 구현해서 <code class="language-plaintext highlighter-rouge">LinearIterator</code> 만들어보기 p180</li> <li><code class="language-plaintext highlighter-rouge">swap</code>이나 <code class="language-plaintext highlighter-rouge">std::move</code>를 사용하더라도, <code class="language-plaintext highlighter-rouge">noexcept</code>로 명시해야함. p189</li> <li><code class="language-plaintext highlighter-rouge">std::ranges::view</code> 에는 다양한 Lazy Evaul or functional 기능이 있다 C++20, p206</li> <li><code class="language-plaintext highlighter-rouge">std::ranges::action</code> 즉각적인 평가를 수행하고, <code class="language-plaintext highlighter-rouge">Mutable</code> 하다.</li> <li>C++ 자원관리 <code class="language-plaintext highlighter-rouge">RAII (Resource Acquisition is Initialization)</code> p239</li> <li>명시적 새로운 new 선언! 신기했다. p243</li> <li><code class="language-plaintext highlighter-rouge">Reflection</code>을 <code class="language-plaintext highlighter-rouge">tie</code>로 구현하는 재미 310p</li> <li><code class="language-plaintext highlighter-rouge">shared_ptr</code> 복사와 생성은 쓰레드 안전하지만, 안에 있는 데이터는 쓰레드 세이프 하지 않다. p394 + cppreference</li> </ol> <h1 id="요약">요약</h1> <ol> <li>캡처가 된다면 람다는 클래스화가 되는거였다! p76</li> </ol> <p>이것은 이전부터 설명하던 내용이여서 바로 생략을 하도록 한다.</p> <ol> <li>이동 시맨틱은 rust의 소유권 이전과 동일하다.</li> </ol> <p><code class="language-plaintext highlighter-rouge">std::move</code>나 <code class="language-plaintext highlighter-rouge">std::forward</code>에서 이 함수들은 도대체 무슨 역할을 하는지 이해하게 되었다. 정말 단순하게 생성자와 복사 행위를 멈추기 위해서, <code class="language-plaintext highlighter-rouge">auto p = std::move(var)</code>를 사용하여 <code class="language-plaintext highlighter-rouge">var</code>에 대한 접근 권한을 빼앗고, <code class="language-plaintext highlighter-rouge">p</code>에게 전달하는 것이다. 이것이 왜 필요한가에 대해서는 함수로 넘어가게 된다면 말이 달라지게 되는 것이였다.</p> <p>극히 정말로 단순하게 함수에서 구조체나 클래스가 넘어가게 될 경우 포인터나 레퍼런스 타입으로 값을 전달하지 않는다면 반드시 생성자나 복사가 발생하게 된다. 하지만 가끔 사람들이 포인터나 레퍼런스 값을 전달해준 이후에 소유권 자체를 완전히 넘겨주고 싶은 경우가 존재한다. 예시로 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>이 있으며, 단일 객체로만 존재해야하는 경우도 존재한다. 그렇기 때문에, <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>의 경우에 복사나 생성자가 호출되는 순간 2개 이상의 객체가 생성이 되므로 문제가 생기게 되고, 포인터로 넘겨지게 된다면 해당 객체를 가르키는 변수가 2개 이상이므로 문제가 생기게 된다.</p> <p>그래서 이러한 문제를 없애기 위해 <code class="language-plaintext highlighter-rouge">std::move</code>와 <code class="language-plaintext highlighter-rouge">std::forward</code>가 존재하게 되는 것 이였다. 크게 어렵게 생각할 이유가 없는것 같다.</p> <ol> <li>평행 배열이 존재할 때, 구조체의 변수의 크기가 작다면, 캐시 라인에 많은 배열이 들어가므로, 속도 개선이 된다. p158</li> </ol> <p>이 부분에 대한 내용은 정말로 신기하였으며, 당연하면서도 새로운 기분을 주는 듯한 내용이였다. 구조체의 데이터가 배열 형태로 존재하고, 구조체의 크기가 작으면 작을 수록 한번의 캐시로의 데이터 이동으로 많은 데이터를 옮길 수 있게 되므로 성능 향상에 도움이 되는 것이다.</p> <p>그렇다면 기존에 거대해진 구조체를 어떻게 성능 향상을 시킬수 있는가? 에 대한 질문으로는 포인터를 적극 활용하여 해결 할 수 있다는 것이다. 즉, 구조체 1개로 모든 데이터를 담는 것이 아닌, 구조체 3개 4개로 분할해서 만들고, 1개의 구조체에 나머지 구조체를 포인터 형태로 간접 접근 하는 방식으로 채택한다면, 하나의 캐시 라인에 최대한 많은 데이터가 모두 들어갈 수 있다.</p> <p>단점으로는, 포인터화되어서 간접적으로 접근하게 된 값은 2중 참조하여야 접근이 되므로 더 많은 성능을 요구하게 된다라는 것이 큰 단점이다. 그렇기 때문에 적절한 조절이 필요한, 그리고 최적화가 가능한 부분이라고 필자는 생각한다.</p> <ol> <li>C++ 자원관리 <code class="language-plaintext highlighter-rouge">RAII (Resource Acquisition is Initialization)</code> p239</li> </ol> <p>정말로 몰랐던 내용으로는 <code class="language-plaintext highlighter-rouge">Stack</code>과 <code class="language-plaintext highlighter-rouge">Heap</code> 메모리에 대한 정의나 실질적으로 활용되는 언어는 극히 드물다는 것을 알게 되었습니다. 대표적으로 <code class="language-plaintext highlighter-rouge">Java</code>나 <code class="language-plaintext highlighter-rouge">Python</code>의 경우에는 모든 변수들을 <code class="language-plaintext highlighter-rouge">Heap</code>에만 저장하므로 <code class="language-plaintext highlighter-rouge">Stack</code>에서는 따로 관리가 되고 있지 않다는 것을 알게 되었습니다. 물론 <code class="language-plaintext highlighter-rouge">Java</code>의 경우에는 모든 변수가 포인터 형태로 관리가 되고 있기 때문에, <code class="language-plaintext highlighter-rouge">Stack</code>을 활용하기도 하나, 대부분은 생성되는 변수는 <code class="language-plaintext highlighter-rouge">Stack</code>에는 포인터 변수가, <code class="language-plaintext highlighter-rouge">Heap</code>에는 실제 데이터가 있는 구조로 되어 있습니다.</p> <p>그래서 <code class="language-plaintext highlighter-rouge">Stack</code>에 데이터 저장과 <code class="language-plaintext highlighter-rouge">Heap</code>에 데이터를 저장을 원하는대로, 그리고 명시적으로 지정이 가능하므로 이를 활용한 자원 관리 기법이란 것이 나타났는데, 그것이 바로 <code class="language-plaintext highlighter-rouge">RAII(Resource Acquisition is Initialization)</code>입니다.</p> <p><code class="language-plaintext highlighter-rouge">GC(Garbage Collect)</code> 없는 C++ 에서는 <code class="language-plaintext highlighter-rouge">Stack</code> 메모리에서 데이터의 삭제를 시기를 기준으로 자원을 관리하는 것 입니다. 즉, 아래와 같은 코드로 자원을 관리 할 수 있습니다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//* 어딘가 Timer란 구현체가 존재함.</span>

<span class="p">{</span>
    <span class="n">ScopedTimer</span> <span class="n">t</span><span class="p">(</span><span class="s">"Something Work!"</span><span class="p">);</span>

    <span class="c1">// Do Working</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 코드를 실행하게 되었을 때, <code class="language-plaintext highlighter-rouge">t</code>란 변수가 <code class="language-plaintext highlighter-rouge">Stack</code>으로 부터 파괴가 되었을 때 실행 시간을 출력하는 기능을 만들 수 있습니다.</p> <ol> <li><code class="language-plaintext highlighter-rouge">shared_ptr</code> 복사와 생성은 쓰레드 안전하지만, 안에 있는 데이터는 쓰레드 세이프 하지 않다.</li> </ol> <p>뭔가 처음에는 <code class="language-plaintext highlighter-rouge">shared_ptr</code>에 있는 <code class="language-plaintext highlighter-rouge">counter</code>가 <code class="language-plaintext highlighter-rouge">atomic</code>하다고 알고 있었는데, 이 말이 무슨말인지 처음에는 이해가 잘 되지 않았다. 하지만 다시 생각해보면 당연하다는 말이라는 것을 알게 되었다.</p> <p><code class="language-plaintext highlighter-rouge">shared_ptr</code>이 복사나 대입을 통해 새롭게 생성이 된다면 <code class="language-plaintext highlighter-rouge">counter</code>가 <code class="language-plaintext highlighter-rouge">atomic</code>하므로 멀티 쓰레드 환경에서 문제가 발생하지 않는다. 하지만 멀티 쓰레드 환경에서 <code class="language-plaintext highlighter-rouge">shared_ptr</code>을 사용한다면 말이 달라지게 된다 <code class="language-plaintext highlighter-rouge">shared_ptr</code>에 있는 데이터는 <code class="language-plaintext highlighter-rouge">atomic</code>한 것이 아니기 때문이다. 즉, <code class="language-plaintext highlighter-rouge">shared_ptr</code>이 가르키는 포인터는 <code class="language-plaintext highlighter-rouge">atomic</code>하지 않고, 오직 <code class="language-plaintext highlighter-rouge">counter</code>만이 <code class="language-plaintext highlighter-rouge">atomic</code>하다.</p> <p>원문으로는 아래와 같으며, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">[공식 문서]</a> 이다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different shared_ptr objects without additional synchronization even if these objects are copies and share ownership of the same object. If multiple threads of execution access the same shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur; the std::atomic&lt;shared_ptr&gt; can be used to prevent the data race.
</code></pre></div></div> <p>정말로 당연하면서도,,, 실수를 많이 할 것 같은 내용이였다.</p> <h1 id="결론">결론</h1> <p>일부 설명하지 않은 내용인 C++ 20에 대한 내용(<code class="language-plaintext highlighter-rouge">views</code>나 <code class="language-plaintext highlighter-rouge">action</code>), <code class="language-plaintext highlighter-rouge">Memory Arena</code>와 같은 추가적인 메모리 생성/파괴 관련 최적화(<code class="language-plaintext highlighter-rouge">new</code>, <code class="language-plaintext highlighter-rouge">delete</code>) 내용 또한 워낙에 쉽게 설명이 되어 있어서 정말로 좋았다.</p> <p>C++ 20에 대한 내용을 요약에 담지 않은 이유로는 한번 직접 읽어 보았으면 하는 느낌이 강하였으며, <code class="language-plaintext highlighter-rouge">Memory Arena</code>의 경우에는 필자가 아직도 완벽하게 이해를 못한 것 같으므로, 내용을 생략하게 되었다.</p> <p>필자가 이해한 <code class="language-plaintext highlighter-rouge">Memory Arena</code>를 간단하게 설명하자면 거대한 메모리를 사전에 생성하고 new 나 delete 직접 구현하여 Memory Allocator를 제공한다. 그리고 사전에 생성된 거대한 메모리가 부족하다면 추가적으로 <code class="language-plaintext highlighter-rouge">Heap</code>에 메모리를 할당하는 방식으로, 그냥 새로운 메모리 <code class="language-plaintext highlighter-rouge">Allocator</code>를 위한 공간을 생성하는 객체라고 생각하게 되었다.</p> <p>그렇지만… 필자가 간단하게 검색한 <code class="language-plaintext highlighter-rouge">Arena</code>는 그러한 것이 아니였으므로 조금 더 근본적인 <code class="language-plaintext highlighter-rouge">Memory Arena</code>에 대해서 공부할 예정이다.</p>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Review"/><category term="read"/><category term="cpp"/><category term="book"/><category term="high"/><category term="performance"/><category term="high-performance"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">Programming Language with LLVM in Udemy 인강을 듣고 나서</title><link href="https://blog.udon.party/blog/2024/frontend-of-llvm/" rel="alternate" type="text/html" title="Programming Language with LLVM in Udemy 인강을 듣고 나서"/><published>2024-07-05T00:00:00+00:00</published><updated>2024-07-05T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/frontend-of-llvm</id><content type="html" xml:base="https://blog.udon.party/blog/2024/frontend-of-llvm/"><![CDATA[<h1 id="개요">개요</h1> <p>본 글은 정말로 뻘글이 될 수 도 있으며, 단순히 LLVm의 프론트엔드를 어떻게 만들어야 하는지, LLVM에 대해서 조금 더 공부해보기 위해서 인강을 수강하게 되었다. 특히, 나만의 컴파일러를 만들어 보고싶다는 생각은 코딩을 시작할 때 부터 가졌었던 나만의 욕심중 하나 였던것이 조금 컸었던것 같기도 하다.</p> <p>해당 프로젝트는 필자가 중학교 2학년 때, 처음으로 한번 인터프리터 언어를 만들어 보고 싶어서 만들게 된 프로젝트이다. <a href="https://github.com/Piorosen/Korea-Compiler">[Korea-Compiler]</a>는 정말로 단순한 구조를 가졌으며, 어떻게 보면 중학교 2학년 학생이 만들만한 문법 구조이다.</p> <p>이 처럼, 필자는 약간 컴파일러나 인터프리터를 만들어 보고 싶었던 것 도 있었으며, 대학원 진학을 컴파일러 분야로 가게된 것도 하나의 인강을 듣게된 이유가 되었다. 솔직하게는, 책이나 자료가 너무 없었기도 했고 빠르게 LLVM 프론트엔드가 어떻게 구성이 되었는지 궁금하였기 때문에 인강을 구매하게 된 이유이다.</p> <h1 id="내용">내용</h1> <p>내용 자체가 후기다 보니, 강의에 대한 내용 및 코드에 대해서 직접적으로 언급은 하지 않는다.</p> <p>만약 강의에 대한 <code class="language-plaintext highlighter-rouge">Demo</code>에 대한 내용은 <a href="https://www.youtube.com/watch?v=Lvc8qx8ukOI">[유튜브]</a> 에서 먼저 들을 수 있다. 그리고 내용 자체가 <code class="language-plaintext highlighter-rouge">중급자</code>로 잡혀져 있기도 하며, 사전에 충분한 컴파일러와 C++에 대해서 알고 있어야하는 내용이 많다.</p> <p>내용으로는 <code class="language-plaintext highlighter-rouge">Eva</code>라는 새로운 언어를 만들고, 해당 언어에 대해서 <code class="language-plaintext highlighter-rouge">Parser</code>에 대한 구현은 생략하고, 오직 <code class="language-plaintext highlighter-rouge">AST</code>와 <code class="language-plaintext highlighter-rouge">Code Generation</code> 분야에 대해서만 서술되어지고 있다. 이때, 최대한 <code class="language-plaintext highlighter-rouge">Eva</code>라는 언어는 <code class="language-plaintext highlighter-rouge">LLVM IR</code>을 생성하고, <code class="language-plaintext highlighter-rouge">clang++</code>을 통해서 실행 바이너리를 생성하는 구조이다. 때문에, 강의는 오직 <code class="language-plaintext highlighter-rouge">Frontend</code>, <code class="language-plaintext highlighter-rouge">AST</code>와 <code class="language-plaintext highlighter-rouge">Code Generation</code> 을 수행한다.</p> <p>공부를 하긴 했지만,,, 너무 추상적이기도 하며 필자가 이해를 잘 못한것 같기도 하다. 불구하고,,, 배운 내용을 기억하고자 정리를 하자면 아래와 같다.</p> <ol> <li><code class="language-plaintext highlighter-rouge">dynamic library</code>를 <code class="language-plaintext highlighter-rouge">IR</code> 생성하는 단계에서 <code class="language-plaintext highlighter-rouge">linking</code> 및 <code class="language-plaintext highlighter-rouge">Verify</code> 할 수 있다. <ul> <li><code class="language-plaintext highlighter-rouge">printf</code> 나 <code class="language-plaintext highlighter-rouge">malloc</code> 을 외부에서 가져올 수 있다.</li> <li><code class="language-plaintext highlighter-rouge">Stack</code>에 메모리 할당 하는 것은 <code class="language-plaintext highlighter-rouge">alloca</code>이라는 <code class="language-plaintext highlighter-rouge">LLVM IR</code>의 <code class="language-plaintext highlighter-rouge">ISA</code>에서 정의할 수 있지만 <code class="language-plaintext highlighter-rouge">Heap</code>에 정의하려면 <code class="language-plaintext highlighter-rouge">malloc</code>을 사용하더라~</li> </ul> </li> <li>결국엔 코드 생성하기 위해서 변수 선언 부터 모든것을 만들어야 한다. <ul> <li>변수를 만들고 싶으면 Create Variable 해서 생성해야하고, 임시 변수를 사용하거나 무엇을 하던지 간에 생성해야한다.</li> </ul> </li> <li>변수나 함수를 생성했다면, 컴파일러 내부에서 기억하고 있어야 한다. <ul> <li><code class="language-plaintext highlighter-rouge">LLVM</code>은 변수나 함수를 생성하였다면 IR 생성하고 끝나지, 직접적인 관리는 <code class="language-plaintext highlighter-rouge">Frontend</code>나 <code class="language-plaintext highlighter-rouge">Own Compiler</code> 에서 관리를 해야한다.</li> <li>하지 않았다면 잃어버린 것이다.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">Control Flow</code>는 대박이다! 모든 것이 <code class="language-plaintext highlighter-rouge">GoTO</code>로 이뤄진다. 그것은 <code class="language-plaintext highlighter-rouge">GOTO</code>이다 <ul> <li><code class="language-plaintext highlighter-rouge">if</code> 문으로 이뤄졌다면 <code class="language-plaintext highlighter-rouge">goto</code>는 2개로 이뤄져 있다.</li> </ul> <ul> <li><code class="language-plaintext highlighter-rouge">if</code> 문 내부와 <code class="language-plaintext highlighter-rouge">if</code> 문이 끝났을 때</li> </ul> </li> <li>구조체는 <code class="language-plaintext highlighter-rouge">GEP</code> 이라는 LLVM의 명령어로 동작된다. <ul> <li><code class="language-plaintext highlighter-rouge">LLVM IR</code>에서는 구조체를 생성하고 나서 각 내부 변수마다 인덱스를 지정한다.</li> <li>해당 인덱스는 추후, <code class="language-plaintext highlighter-rouge">GEP</code> 이라는 <code class="language-plaintext highlighter-rouge">Inst</code>에서 이름이 아닌, 인덱스로 호출된다.</li> <li><code class="language-plaintext highlighter-rouge">GEP</code>은 다용도로 사용이 가능하도록 만들기 위해서 <code class="language-plaintext highlighter-rouge">배열 구조체 구조체</code> 라면 Index 3개(varadic) 지정 할 수 있도록 되어 있다.</li> </ul> </li> <li>비 캡처 함수와 람다 함수는 구현적으로 <code class="language-plaintext highlighter-rouge">매우 매우</code> 다르다. <ul> <li>비 캡처 함수는 컴파일러 입장에서 함수와 동일하므로, 이름만 랜덤한 난수로 지정하면 <code class="language-plaintext highlighter-rouge">Lambda-Lifting</code> 기법을 통해 만들어 질 수 있다.</li> <li>캡처 함수는 생각해보자! 캡처된 변수를 <code class="language-plaintext highlighter-rouge">Heap</code> 저장하고 <code class="language-plaintext highlighter-rouge">Free</code> 할 것인가? 너무 비효율적이지 않는가?</li> <li>그렇다면 <code class="language-plaintext highlighter-rouge">전역 변수(Global)</code>하게 만들 것인가? 그렇다면 만약, Closure 처럼 함수를 생성하는 함수 구조라면 어떻게 될 것인가? 매번 생성하기에는 어렵지 않는가?</li> <li>그래서 람다 함수는 클래스화하여, 함수 포인터와 캡처된 변수를 함께 소유하고 있는 구조라면 가능하다!</li> <li>그렇다! 본 강의에서는 함수형 프로그래밍의 <code class="language-plaintext highlighter-rouge">Closure</code>는 호출 가능한 객체와 동일하다고 서술되어지고 있다.</li> </ul> </li> <li>클래스 상속에서 발생 가능한 가상 함수는 정말로 신기한 구조였다. <ul> <li>필자가 작성한 2가지의 예시를 통해 가상 함수에 대해서 완벽! 이해를 할 수 있을거라 생각한다.</li> </ul> </li> </ol> <p>필자가 작성한, 클래스에 대한 예시 코드이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">FuncPtr</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)();</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base class"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">show</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived class "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}};</span>
</code></pre></div></div> <p>먼저 <code class="language-plaintext highlighter-rouge">Base</code> 클래스와 <code class="language-plaintext highlighter-rouge">Derived</code> 클래스의 크기를 확인해보자. 아래의 값을 확인해 본다면, 빌드 환경이 <code class="language-plaintext highlighter-rouge">x64</code>라면 <code class="language-plaintext highlighter-rouge">8</code>, <code class="language-plaintext highlighter-rouge">16</code> 이 나타나게 되고, <code class="language-plaintext highlighter-rouge">x86</code>이라면 <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">8</code>이 나타나게 된다. 즉, 이를 통해 무언가가 모르겠지만 <code class="language-plaintext highlighter-rouge">virtual</code> 이란 것 때 포인터 변수가 하나 존재한 다는 것을 실험적으로 확인 할 수 있다. 그리고 해당 변수가 사실 <code class="language-plaintext highlighter-rouge">vtable</code>, 가상 테이블(함수 목록을 간접적으로 가르키는) 변수라는 것을 실험적으로 확인해 볼 수 있다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Derived</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>아래의 코드에서 강제적으로 캐스팅 연산을 수행하고, 함수 포인터로 호출하는 과정을 나타내보았다. <code class="language-plaintext highlighter-rouge">Derived</code>에도 <code class="language-plaintext highlighter-rouge">vtable</code>이 존재하므로 <code class="language-plaintext highlighter-rouge">vtable</code>에 있는 첫번째 함수 포인터가 <code class="language-plaintext highlighter-rouge">show</code> 이므로 <code class="language-plaintext highlighter-rouge">show in Derived</code>가 호출이 되는 것을 알 수 있다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">**</span> <span class="n">vptr</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">***&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">FuncPtr</span> <span class="n">func</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">FuncPtr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">func</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>만약에 <code class="language-plaintext highlighter-rouge">vtable</code>이 잘 이해가 되지 않는다면 아래의 그림을 보면 이해가 된다. (정말 뇌 뺴고 ChatGPT에게 맡기니 잘 그려준다…)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Base Class:
  +---------------------+
  | vtable pointer -----|----+
  +---------------------+    |
  | VirtualFunction1()  |    |
  +---------------------+    |
  | VirtualFunction2()  |    |
  +---------------------+    |
                             |
                             v
                     +---------------+
vtable for Base      | &amp;VirtualFunc1 |
Class:               +---------------+
                     | &amp;VirtualFunc2 |
                     +---------------+

Derived Class:
  +---------------------+
  | vtable pointer -----|----+
  +---------------------+    |
  | VirtualFunction1()  |    |
  +---------------------+    |
  | VirtualFunction2()  |    |
  +---------------------+    |
                             |
                             v
                     +---------------+
vtable for Derived   | &amp;DerivedFunc1 | (overrides VirtualFunc1)
Class:               +---------------+
                     | &amp;VirtualFunc2 | (inherits from BaseClass)
                     +---------------+
</code></pre></div></div> <h1 id="후기">후기</h1> <p>결론적으로는 아직까진 자세히 (완벽하게는) 모르겠지만, 어셈블리와 같이 모든 코드를 작성해줘야한다는 것은 알게 되었다. 또한, 클래스 부분에서 필자가 알던 것 처럼 <code class="language-plaintext highlighter-rouge">Class</code>는 사실 구조체에 <code class="language-plaintext highlighter-rouge">정적 함수</code>로 바뀐다는 것을 알고 있었지만 이를 강의에서 직접 코드로 보여줌으로 써 얻는 희열도 있었다.</p> <p>그리고 가장 신기하였던 부분으로는 상속으로 인한 <code class="language-plaintext highlighter-rouge">vtable</code>이란 내용에서 이전에 읽은 <code class="language-plaintext highlighter-rouge">Optimized C++</code> 책에서 <code class="language-plaintext highlighter-rouge">가상 함수</code>는 매우 느리다 란 내용에서 왜 느린지, 어떻게 동작이 되는지에 대해서 컴파일러 레벨에서 공부 할 수 있어서 매우 좋은 기회가 되었다.</p> <p><a href="https://www.udemy.com/certificate/UC-b8d5cd33-2c1a-4717-83b3-b0ef241bc2d2/"><img src="/assets/img/post/2024-07-05-01.jpg" alt=""/></a></p>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Review"/><category term="udemy"/><category term="llvm"/><category term="lagnauge"/><category term="online"/><category term="course"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">Optimized C++ 책을 읽고나서</title><link href="https://blog.udon.party/blog/2024/my-comment-of-reading-optimized-cpp/" rel="alternate" type="text/html" title="Optimized C++ 책을 읽고나서"/><published>2024-06-22T00:00:00+00:00</published><updated>2024-06-22T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/my-comment-of-reading-optimized-cpp</id><content type="html" xml:base="https://blog.udon.party/blog/2024/my-comment-of-reading-optimized-cpp/"><![CDATA[<h1 id="개요">개요</h1> <p>1줄 요약: 초보자를 위한 책도 아닌, 중급자 그 이상이 읽어야 정말 재밌습니다.</p> <p>C++ 언어를 공부하면서 조금 더 많은 언어적인 테크닉에 대해서 공부하고 싶었었다. 그래서 컴파일러를 통해 배우는 C++ 언어라던지, Effective C++ 등 다양한 책을 읽어보았었다. 특히, 필자는 언어적인 테크닉 외에 조금 무언가 로우 레벨적으로 최적화를 이뤄보고 싶었기 떄문에 <code class="language-plaintext highlighter-rouge">Optimized C++</code> 책을 읽어보고 싶다! 란 생각을 하게 된 것 같다. 결론적으로 이야기를 하자면 나름 재미있었고, C++의 STL 라이브러리는 상당히 빠르면서 동시에 범용성을 지녔기 때문에 느리다는것을 알게 되었다. 그래서 STL 라이브러리를 사용하는것 보다 직접 구현한다면 (C언어 형태로 구현한) 성능 개선이 상당히 이뤄질수 있다는 것이 인상적이였다.</p> <p><code class="language-plaintext highlighter-rouge">Optmized C++</code>의 책에서 이야기 하는 내용은 하드웨어적인 최적화 관련된것이 아닌, 범용적으로 언어적인 레벨, 이동식 시멘트나 생성자, 메모리 매니저와 같은 내용이였다. 그래서 이 책을 읽고자하는 독자가 있다면, 어떻게 코드를 이쁘고 효율적으로 최적화할것인지 한다면 최고인 책인것 같다. 즉, 하드웨어적인 (캐시 메모리, 하드웨어의 Instruction Set Architecture에 종속적이지 않은) 내용은 없다.</p> <h1 id="핵심-내용">핵심 내용</h1> <p>필자가 재밌게 읽었던 부분을 요약하자면 아래와 같고, 이름은 필자가 조금 변형하였다.</p> <ol> <li>메모리를 읽는건 1바이트가 아닌 동시에 많은 데이터를 읽습니다. (45p)</li> <li>문자열은 잦은 메모리 재할당과 복사가 자주 발생합니다. (110p)</li> <li>기초적인 알고리즘 최적화 기법 (chapter 5) (너무 당연한 이야기들)</li> <li>스마트 포인터는 성능과 거리가 멉니다. (162p)</li> <li>비 캡처 람다는 일반 정적 함수에서 이름이 없는 것과 같다. (위치 까먹었습니다..)</li> <li>클래스 상속과 가상 함수는 매우 매우 매우 느리다. (위치 까먹었습니다..)</li> <li><code class="language-plaintext highlighter-rouge">do-while</code>은 어셈블리 입장에서 효율적 입니다. (위치 까먹었습니다..)</li> <li>라이브러리 바깥에서 메모리 할당하도록 결정하세요. (264p) RVO 기법(187p)</li> <li>검색 및 정렬 최적화 챕터(최고!) <a href="http://ascode.org/problem.php?id=1457">[너무 재밌어서 문제로 만들어보았습니다.]</a></li> <li>메모리 관리 최적화 (너무 어렵습니다..)</li> </ol> <h1 id="요약">요약</h1> <p>필자가 열심히 공부하면서 얻었던 지식을 한번 더, 책으로 읽을수 있어서 정말로 좋았습니다. 하지만, 책의 두께라던지, 각 문단 문단 하나가 너무 크게 <code class="language-plaintext highlighter-rouge">퉁</code> 쳐져 있는 듯하고, 너무 광대한 범위를 적은 페이지수로 설명하다 보니 아쉬웠던 점이 넘 많았습니다. 예시로는 필자가 작성한 핵심 내용 (1) 으로, CPU 는 메모리로 부터 데이터를 읽을 때 1 바이트씩 읽는것이 아닌 64 바이트씩 데이터를 읽는다. 라는 내용이다. 여기서, <code class="language-plaintext highlighter-rouge">Optmized C++</code>은 단순하게 메모리는 랜덤 엑세스가 가능하지만, 캐시 메모리로 인해, 순차 접근하는것이 더 효율적이다 라는 내용으로 끝나게 된다.</p> <p>하지만, 실상은 여기서 끝나는것이 아니라, 멀티 쓰레드 환경에서 <code class="language-plaintext highlighter-rouge">False Sharing</code>이라는 문제도 발생한다. 이 처럼 뭔가… 책의 페이지수를 2000 페이지이나 3000 페이지로 늘려도 괜찮으니, 더 자세하고 많은 내용으로 적어줬으면 좋았을것 같았다. (약간 욕심이다.)</p> <p>각각 요소를 필자가 기억하기 정리하는 목적으로 작성할 계획이다.</p> <h2 id="요약-2">요약 2</h2> <ol> <li>메모리를 읽는건 1바이트가 아닌 동시에 많은 데이터를 읽습니다. (45p)</li> </ol> <p>엄청 옛날의 시스템이나, 아두이노 같은 마이크로 프로세서의 경우에는 CPU에 집적가능한 회로의 수가 적으므로 프로그램 코드를 메모리로 부터 읽는것에 많은 회로를 작성하는 것이 어렵다. 또한, 캐시 메모리 없이 DRAM에서 바로 Register로 적재하는 경우도 있다. 그렇지만 이는 엄청 적은 임베디드 시스템이지, 일반적인 대형 컴퓨터 또는 일반 컴퓨터에 들어가는 CPU (x86 계열)의 경우에는 캐시메모리와 더 많은 레지스터, 한 번에 많은 데이터를 DRAM으로 부터 읽어온다. 따라서 일반적인 컴퓨팅 환경에서는 1바이트씩 메모리로부터 읽는것이 아닌 64 바이트나 특정 바이트의 수 만큼 데이터를 읽어서 캐시 메모리로 데이터를 적재한다.</p> <p>그렇기 때문에, DRAM은 랜덤 엑세스가 가능하지만, 캐시 메모리로 데이터를 읽어서 적재하는 과정에서 순차적으로 데이터가 정렬되어 있어야 효율적이므로, 최대한 메모리를 순차적으로 정렬해 두는것이 좋다.</p> <p>그렇다면 여기서 의문이 들 수 있다. 캐시 메모리의 크기에 맞춰서 데이터를 읽고, 재정렬하고 랜덤 액세스 하도록 만든다면 성능 개선이 이뤄질까? 라는 내용이다. 정답이다. 놀랍게도 이쪽으로 연구 분야로 <code class="language-plaintext highlighter-rouge">Cache Aware for Computation</code> 이라는 주제로 존재한다.</p> <p>두 번째로 의문은 하나가 더 있다. 해당 책의 경우에서는 딱 하나의 경우, 싱글 쓰레드의 경우에서 문제점을 제기하였다. 그래서 더 많이 다뤄야하는 주제임에도 불구하고, 책의 두께나 내용상으로 생략한 내용이 있다. 필자가 생각하는 추가적인 문제는, 싱글 쓰레드가 아닌 멀티 쓰레드 환경에서 <code class="language-plaintext highlighter-rouge">Cache Memory</code>로 인한 데이터 정합성 쉽게 발생하는 문제가 있다.</p> <p>주제로는 <code class="language-plaintext highlighter-rouge">False Sharing</code> 이라는 주제인데, 코드에서 변수 선언은 <code class="language-plaintext highlighter-rouge">Stack Memory</code>나 <code class="language-plaintext highlighter-rouge">Data Section</code> 에서 생성 되었고, 순차적으로 데이터를 선언했을 때 발생하는 문제이다. 여기서 다룰 주제는 아니므로, 간단하게 설명하자면, 아래의 코드를 생성하고, <code class="language-plaintext highlighter-rouge">A 쓰레드</code> 에서는 변수 <code class="language-plaintext highlighter-rouge">a</code>를, <code class="language-plaintext highlighter-rouge">B 쓰레드</code> 에서는 변수 <code class="language-plaintext highlighter-rouge">b</code>를 접근한다고 가정했을 때 문제가 발생한다. 위에서 이야기했던, <code class="language-plaintext highlighter-rouge">DRAM</code>에 순차적으로 정의 된 <code class="language-plaintext highlighter-rouge">변수 a와 b</code>는 각기 다른 CPU 코어의 캐시 메모리에 함께 적재되는 문제가 있다. 그렇기 때문에, <code class="language-plaintext highlighter-rouge">B 쓰레드</code>에서 사용되지 않는 <code class="language-plaintext highlighter-rouge">변수 a</code>도 함께 적재 되면서 <code class="language-plaintext highlighter-rouge">A 쓰레드</code>에서 <code class="language-plaintext highlighter-rouge">변수 a</code> 값이 변경이 된다면 <code class="language-plaintext highlighter-rouge">B 쓰레드</code>의 <code class="language-plaintext highlighter-rouge">변수 a</code>의 값도 함께 맞춰줘야하므로 생기는 문제이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div> <ol> <li>스마트 포인터는 성능과 거리가 멉니다. (162p)</li> </ol> <p>스마트 포인터는 안정성과 메모리를 반드시 <code class="language-plaintext highlighter-rouge">Alloc</code>과 <code class="language-plaintext highlighter-rouge">dealloc</code> 하기 위해서 내부적으로 얼마나 변수에 대해서 참조하고 있는지 (참조 카운팅, use_count) 계산하고 있다. 하지만, C++ 표준 라이브러리는 안정성을 위해서, 특히 멀티 쓰레드 환경에서도 동작을 보장하기 위해서 참조 카운팅 변수를 <code class="language-plaintext highlighter-rouge">atomic(원자성)</code>으로 지정되어져 있다. 따라서, 스마트 포인터를 이용하여 데이터를 주고 받거나, 생성자, 파괴자가 잦은 호출이 발생이 되는 경우에는 생성자와 파괴자 호출 비용과 추가적으로 <code class="language-plaintext highlighter-rouge">atomic</code>한 변수로 인해 성능 지연이 발생하게 된다.</p> <ol> <li>비 캡처 람다는 일반 정적 함수에서 이름이 없는 것과 같다. (위치 까먹었습니다..)</li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">auto</span> <span class="n">cap_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// lambda</span>
<span class="n">data</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="c1">// correctly work!</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
<span class="n">data</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="c1">// Error! because of captured [data]</span>
<span class="n">cap_data</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span> 
</code></pre></div></div> <p>일반 함수는 코드의 길이가 짧다면 인라인화 되거나, 추가적인 최적화를 수행이 될 가능성이 있다. 그렇기 때문에, 비 캡처 람다 함수는 이상하게도 일반 정적 함수로 치환이 될 수 있고, 이를 통해 인라인화 될 가능성이 존재한다. 그렇다면 호출 스택 지점이나, Program Count의 주소, 함수의 코드 플로우가 변경이 되지 않으므로 성능 이점을 얻을 수 있다. 그렇기 떄문에 약간 신기하지만 비 캡처 람다 함수가 일반 함수와 동일하는 점이 신기하였다.</p> ]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Review"/><category term="read"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">프로젝트, 누가 더 빠르게 알고리즘 문제를 푸는가?</title><link href="https://blog.udon.party/blog/2024/algorithm-competition-with-my-girl-friend/" rel="alternate" type="text/html" title="프로젝트, 누가 더 빠르게 알고리즘 문제를 푸는가?"/><published>2024-06-13T00:00:00+00:00</published><updated>2024-06-13T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/algorithm-competition-with-my-girl-friend</id><content type="html" xml:base="https://blog.udon.party/blog/2024/algorithm-competition-with-my-girl-friend/"><![CDATA[<h1 id="개요">개요</h1> <p>너와 나! 경쟁이다! <a href="https://github.com/oMFDOo/whimpering.git">[프로젝트 코드]</a> <a href="https://github.com/oMFDOo/whimpering/issues">Issue on Github</a> 에서 문제 번호와 제목, 번호를 입력하고 대결을 신청한다면 자동적으로 대결이 성립이 된다. 그리고 가장 먼저 정답을 푼 사람이 <code class="language-plaintext highlighter-rouge">프로그램 코드</code>를 작성하면 승리자가 결정이 되고, 참가자의 모두가 <code class="language-plaintext highlighter-rouge">프로그램 코드</code>를 작성하면 자동적으로 <code class="language-plaintext highlighter-rouge">Issue</code>가 <code class="language-plaintext highlighter-rouge">Close</code>되고 게임은 끝나게 된다.</p> <table> <thead> <tr> <th style="text-align: center">Score 현황 판</th> <th style="text-align: center">게임 진행판</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="/assets/img/post/2024-06-13-01.png" alt=""/></td> <td style="text-align: center"><img src="/assets/img/post/2024-06-13-02.png" alt=""/></td> </tr> </tbody> </table> <h1 id="구조-설계">구조 설계</h1> <p>먼저 <code class="language-plaintext highlighter-rouge">1 vs 1</code> 구조이면서, 여러 변수를 고려하기 귀찮음으로 인해 게임 진행하는 플레이어의 값을 매직 넘버로 지정하거나, Github Repo의 값을 매직 넘버로 지정하였음을 먼저 밝힌다. 그러므로 코드를 수정이 필요하다면 상당히 많은… 귀찮음이 동반할 것이라 예상이 된다.</p> <p>가장 큰 구조는 3개의 파트로 나눠져있다.</p> <ol> <li>어떻게 게임을 진행할 것인가?</li> <li>점수를 시각적으로 나타내는 현황판</li> <li>자동적으로 어떻게 코드를 저장할 것인가?</li> </ol> <h2 id="어떻게-게임을-진행할-것인가">어떻게 게임을 진행할 것인가?</h2> <p>먼저 게임의 진행하는 과정에서 알고리즘 푸는 사이트는 정말로 많고 다양하다. 예시로 국내의 경우 백준, 프로그래머스가 있기도 하며, 해외로 넘어가게 Leet Code나 CodeForce등 더 다양하다. 그러므로 자동적으로 저지 사이트의 정보를 수집하여 Github에 정보를 수정하는 것은 매우 어렵고(시간과 노동에 비해서) 복잡하다. 그래서 저지 사이트의 정보를 수집 하는 것이 아닌, 사용자가 직접 코드를 Github Issue로 등록하게끔 구조를 설계하였다.</p> <p>코드를 Github Issue로 등록하게끔 만들었다면 이제 대부분의 문제는 해결이 된 것과 같다. 그 이후 부터는 하나의 규약과 같이 하나씩 하나씩 정의하기만 한다면 무엇이든지 OK가 될 수 있다. 그래서 필자의 경우에는 Github Issue에서 제목부터 어떻게 지정하였는지에 따라서 문제 식별과 어느 저지 사이트에서 풀었는지 정의하도록 만들었다.</p> <p>그리고 지정된 플레이어가 Github Issue에 댓글을 달았다면 자동적으로 제목에 기반하여 레포지토리에 자동적으로 코드를 커밋과 푸시를 하도록 설계하였다. 이 과정에서 지정된 플레이어 중에서 가장 먼저 댓글을 단 사람에게 1점의 스코어를 부여하도록 하였다.</p> <h2 id="점수-계산-방식">점수 계산 방식</h2> <p>점수 계산 하는 알고리즘을 자동적으로 수행하기 위해서 <code class="language-plaintext highlighter-rouge">Github Action</code>을 통해 자동화 하도록 하였다. 그리고 게임 진행 방식에서 <code class="language-plaintext highlighter-rouge">Github Issue</code>에 <code class="language-plaintext highlighter-rouge">Comments</code>를 다는 것으로 점수와 자동적으로 코드를 업로드하는 것으로 정의하였으므로 <code class="language-plaintext highlighter-rouge">github-action.yaml</code>에는 아래와 같이 정의가 된다.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span> <span class="c1"># for purpose of debugging and testing </span>
  <span class="na">issue_comment</span><span class="pi">:</span>
    <span class="na">types</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">created</span><span class="pi">]</span>
</code></pre></div></div> <p>누군가가 댓글을 담으로써, 자동적으로 이벤트가 발생하게 만들었으므로 이제 점수 측정해야하는 Issue나 최근에 등록된 Comments를 읽어서 <code class="language-plaintext highlighter-rouge">Repository</code>에 저장하고, <code class="language-plaintext highlighter-rouge">Score Board</code>에 점수를 갱신하면 된다.</p> <p>필자의 경우에는 점수를 부여하기 위해 이미 점수가된 문제를 저장하고, 누가 이겼는지 기록하는 방식으로 구현하였다. 이유로는 누군가가 거짓으로 데이터를 조작할 수 도 있고, 추후에 누가 어떤 문제를 이겼는지 쉽게 알기 위해서 하나의 데이터베이스와 같은 형식으로 만들게 되었다.</p> <p><code class="language-plaintext highlighter-rouge">Score Board</code>에 점수를 갱신하기 위해 점수 갱신해야하는 점수를 하나의 텍스트 파일에 저장하여 조작이되지 않았음을 검증하기 위한 용도로(Commit 로그 분석용으로) 만들었다.</p> <p><a href="https://github.com/oMFDOo/whimpering/blob/main/scripts/win_list.txt">승리자 목록</a>, <a href="https://github.com/oMFDOo/whimpering/blob/main/scripts/current_score.txt">스코어 보드 점수 판</a></p> <h2 id="점수는-어떻게-출력하고-있나요">점수는 어떻게 출력하고 있나요?</h2> <p>솔직한 마음으로는 점수판은 지금 현재 <code class="language-plaintext highlighter-rouge">README.md</code>로 관리가 되고 있다보니, <code class="language-plaintext highlighter-rouge">README.md</code>파일을 통쨰로 변경해야한다. 그러나 필자의 경우에는 뭔가 Python 코드에서 <code class="language-plaintext highlighter-rouge">README.md</code>의 템플릿이 관리가 되는것은 무언가 매우 비효율적이라 판단하게 되었고, 그 결과 템플릿 엔진을 이용하고로 마음을 먹었고, <code class="language-plaintext highlighter-rouge">JinJa2</code>를 이용하게 되었다. 굳이 <code class="language-plaintext highlighter-rouge">JinJa2</code>를 쓸 필요가 없지만 추후에 <code class="language-plaintext highlighter-rouge">IF</code>나 <code class="language-plaintext highlighter-rouge">For</code>와 같은 복잡한 (만약에) 연산이 필요할 수 도 있으니 사용하게 되었다.</p> <p><a href="https://github.com/oMFDOo/whimpering/blob/main/resources/template_score.md">템플릿 예제</a></p> <p>중요하지 않지만, 약간 필자는 <code class="language-plaintext highlighter-rouge">Go</code>언어로 <code class="language-plaintext highlighter-rouge">kubernetes</code> 제어하면서 <code class="language-plaintext highlighter-rouge">JinJa2</code>에 엄청 마음에 들었기 때문에 애용하고 있다. 그리고 최근에 진행한 프로젝트인 <a href="https://github.com/Piorosen/implement-mnist">MNIST from Keras H5 모델을 C++로 배포/컴파일</a> 프로젝트에서도 C++ 코드 생성할 때 <code class="language-plaintext highlighter-rouge">JinJa2 Template Engine</code>을 이용하였다.</p> <p>README.md를 생성해낸 뒤에 <code class="language-plaintext highlighter-rouge">Github Action</code>을 통해 자동적으로 커밋하여 이전의 README.md만 교체하면 점수는 변경할 수 있다.</p> <h2 id="어떻게-점수판을-그리고-있나요">어떻게 점수판을 그리고 있나요?</h2> <p>이 세상에는 <code class="language-plaintext highlighter-rouge">ASCII ART</code>에 진심인 사람이 정말로 많다. 그 예시로 <code class="language-plaintext highlighter-rouge">ASCII ART</code>를 만든 사람들 끼리 모여서 공유하는 사이트가 있을 정도로 <a href="https://asciinema.org/explore">[ASCII ART Anime]</a> 인기가 많다. 아니면 <code class="language-plaintext highlighter-rouge">Terminal User Interface</code>라 해서 터미널 상에서 GUI 를 구현하는 사람이 있을 정도이다.</p> <p><img src="https://github.com/ArthurSonzogni/FTXUI/assets/4759106/6925b6da-0a7e-49d9-883c-c890e1f36007" alt=""/></p> <p>그렇기 때문에, 우리가 원하는 글자를 아스키 아트로 그리는 것은 매우 쉽고, 어떤 곳은 폰트 단위로 제공하는 곳이 있다. 그것은 바로 필자가 사용한 <code class="language-plaintext highlighter-rouge">pyfiglet</code> 라이브러리이며 공식 사이트는 <a href="http://www.figlet.org/">[사이트]</a> 이다.</p> <p>그래서 쉽게 <code class="language-plaintext highlighter-rouge">pip install pyfiglet</code>으로 설치하고 원하는 폰트를 찾고 <code class="language-plaintext highlighter-rouge">JinJa2</code>에 값을 넘겨주기만 하면 <code class="language-plaintext highlighter-rouge">README.md</code>는 완성이 되는 것이다. 그래서 실질적으로 코드는 라이브러리를 이용하여 호출 하였으므로 구조는 매우 단순하다.</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## 점수를 생성합니다.
# 기본적으로 left pad 를 적용하여, 최소 2글자로 표현되도록 만들었습니다.
</span><span class="k">def</span> <span class="nf">generate_score</span><span class="p">(</span><span class="n">score</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">art</span> <span class="o">=</span> <span class="n">pyfiglet</span><span class="p">.</span><span class="nf">figlet_format</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">score</span><span class="p">).</span><span class="nf">rjust</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">),</span> <span class="n">font</span><span class="o">=</span><span class="sh">"</span><span class="s">3d-ascii</span><span class="sh">"</span><span class="p">).</span><span class="nf">rstrip</span><span class="p">(</span><span class="sh">"</span><span class="se">\r\n</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">art</span>

<span class="c1">## 이름을 생성합니다.
</span><span class="k">def</span> <span class="nf">generate_name</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">art</span> <span class="o">=</span> <span class="n">pyfiglet</span><span class="p">.</span><span class="nf">figlet_format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">font</span><span class="o">=</span><span class="sh">"</span><span class="s">doom</span><span class="sh">"</span><span class="p">).</span><span class="nf">rstrip</span><span class="p">(</span><span class="sh">"</span><span class="se">\r\n</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">art</span>

<span class="k">def</span> <span class="nf">get_current_information</span><span class="p">(</span><span class="nb">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nf">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">reader</span><span class="p">.</span><span class="nf">readline</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">,</span><span class="sh">"</span><span class="p">)))</span>
        <span class="nf">assert</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">winner</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Draw</span><span class="sh">"</span>
        
        <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">winner</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Piorosen</span><span class="sh">'</span>
        <span class="k">elif</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">winner</span> <span class="o">=</span> <span class="sh">'</span><span class="s">oMFDOo</span><span class="sh">'</span>

        <span class="k">return</span> <span class="p">{</span><span class="sh">"</span><span class="s">mfdo</span><span class="sh">"</span><span class="p">:</span> <span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sh">"</span><span class="s">piorosen</span><span class="sh">"</span><span class="p">:</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="sh">"</span><span class="s">win</span><span class="sh">"</span><span class="p">:</span> <span class="n">winner</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">generate_score_table</span><span class="p">(</span><span class="n">template</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">template</span> <span class="o">=</span> <span class="nc">Template</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">read</span><span class="p">())</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">template</span><span class="p">.</span><span class="nf">render</span><span class="p">({</span>
        <span class="sh">'</span><span class="s">win_name</span><span class="sh">'</span><span class="p">:</span> <span class="nf">generate_name</span><span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="sh">'</span><span class="s">win</span><span class="sh">'</span><span class="p">]),</span>
        <span class="sh">'</span><span class="s">mfdo</span><span class="sh">'</span><span class="p">:</span> <span class="nf">generate_name</span><span class="p">(</span><span class="sh">"</span><span class="s">oMFDOo</span><span class="sh">"</span><span class="p">),</span>
        <span class="sh">'</span><span class="s">mfdo_score</span><span class="sh">'</span><span class="p">:</span>  <span class="nf">generate_score</span><span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="sh">'</span><span class="s">mfdo</span><span class="sh">'</span><span class="p">]),</span>
        <span class="sh">'</span><span class="s">piorosen</span><span class="sh">'</span><span class="p">:</span> <span class="nf">generate_name</span><span class="p">(</span><span class="sh">"</span><span class="s">Piorosen</span><span class="sh">"</span><span class="p">),</span>
        <span class="sh">'</span><span class="s">piorosen_score</span><span class="sh">'</span><span class="p">:</span> <span class="nf">generate_score</span><span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="sh">'</span><span class="s">piorosen</span><span class="sh">'</span><span class="p">]),</span>
    <span class="p">})</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <h1 id="결과">결과</h1> <p>안타깝게도… 만들고, 어떤 문제를 풀 것인지 정했지만, 여자친구가 최근에 면접이나 자소서를 쓰게 되면서 정작 이걸 쓸 일이 지금 당장은 없다는게 옥에티이다. 물론, 문제를 이슈에 만들고 댓글을 달면 자동적으로 <code class="language-plaintext highlighter-rouge">Repository</code>에 저장이 되는 것 까지 테스트 했다…</p> <p>누군가가 추후에 이 글을 읽겠지만, 그 때에는 이 프로젝트가 쓰여졌었길 바란다…</p> <ul> <li>원래 <code class="language-plaintext highlighter-rouge">BackjoonHub</code>란 프로젝트와 연계해서 사용할 계획이였다만, 개인을 위한 프로젝트이다 보니 본 프로젝트에 적합하지 않았다. 다만, <a href="https://github.com/BaekjoonHub/BaekjoonHub/issues/106#issuecomment-2154979678">[BackjoonHub 이슈]</a>를 발행하여 혹시나… 개인용이 아닌, 여러명이서 사용할 수 있으면 어떨지에 대해서 추가한 상황이다.</li> </ul> <p>만약 누군가가 이긴다거나, 점수가 갱신된다면 아래와 같은 결과로 나타나게 된다.</p> <p><img src="/assets/img/post/2024-06-13-03.png" alt=""/></p> <h1 id="후설">후설</h1> <p>개발 시간은 무려 5~6 시간 정도 소요하였다. 누군가는 일회성 프로젝트인데 왜 이렇게 까지 구현하는지에 대해서 의문을 가질수 있겠지만, 필자의 경우에는 <code class="language-plaintext highlighter-rouge">재밌잖아?</code> 그리고 얼마전에 토익 시험에서 815점이 나와서 이제 백수인데, 6시간 정도는 태울만 하잖아? 라는 느낌이다. 또한, 블로그 포스팅이나 여자 친구와 함께 코딩 대결 할 수 있는 플랫폼 만드는건 <code class="language-plaintext highlighter-rouge">더 재밌잖아?</code> 원래 코딩은 재밌으려고 하는게 아니야? 라는 느낌으로 개발을 뚝딱 해버렸다.</p> <p>요새 정말 다양한 프로젝트를 동시에 하고 있다. 가상 머신 부터 컴파일러까지 만들어보는 <code class="language-plaintext highlighter-rouge">https://github.com/DreamscapeVM</code> 프로젝트, 직접 <code class="language-plaintext highlighter-rouge">Keras to CPP for MNIST</code> 프로젝트인 <code class="language-plaintext highlighter-rouge">https://github.com/Piorosen/implement-mnist</code> 이 있다.</p>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Develop"/><category term="github-action"/><category term="github"/><category term="algorithm"/><category term="automatically"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">MNIST from Keras H5 모델을 C++로 배포/컴파일</title><link href="https://blog.udon.party/blog/2024/implemnt-mnist/" rel="alternate" type="text/html" title="MNIST from Keras H5 모델을 C++로 배포/컴파일"/><published>2024-06-08T00:00:00+00:00</published><updated>2024-06-08T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/implemnt-mnist</id><content type="html" xml:base="https://blog.udon.party/blog/2024/implemnt-mnist/"><![CDATA[<h1 id="개요">개요</h1> <p>코딩은 언제나 즐겁고 나를 재밌게 만들어준다. 필자가 학부생일 때, 만들고 운영했던 저지 사이트는 현재 하나의 학과 중간/기말고사에 쓰여지고 있다. 또한, 학과에서 학생이 직접 문제를 만들어서 사이트에 올릴 수 있고, 필자는 졸업했음에도 불구하고 아직까지 문제 생성 권한이 남아있다. <a href="http://ascode.org/">[학괴 저지 사이트]</a> 그래서, 단순히 백준이나 프로그래머스에서 쉽게 볼 수 있는 알고리즘 문제가 아닌 뭔가 다이나믹하고 머리에 짜릿한 문제를 만들기 위해서 고심하던 중 <code class="language-plaintext highlighter-rouge">MNIST</code>를 이미지 데이터셋이 주어지고, 어떠한 숫자인지 판별하는 코드를 작성하도록 하면 정말 재미있을 것이라 생각하게 되었다.</p> <p>현재 <code class="language-plaintext highlighter-rouge">MNIST</code>는 <code class="language-plaintext highlighter-rouge">NLP</code>에 비해 인기가 많이 식었지만, 아직까지도 인공지능 공부한다면 거의 반드시 접하게 되는 데이터 셋 중 하나이다. 그렇기 때문에 <code class="language-plaintext highlighter-rouge">딥 러닝</code>뿐만 아니라 <code class="language-plaintext highlighter-rouge">SVM</code>, <code class="language-plaintext highlighter-rouge">Bayesian</code>, 기타 등등을 직접 구현하여 이미지가 입력이 되었을 때, 숫자를 판별하는건 쉬울 것이라 생각하였다. 다만, 학과 저지 사이트의 경우에는 한계점이 존재했는데, <code class="language-plaintext highlighter-rouge">네트워크 통신 금지</code>, <code class="language-plaintext highlighter-rouge">어셈블리 금지</code>, <code class="language-plaintext highlighter-rouge">시스템 커널 직접 접근 금지</code>, <code class="language-plaintext highlighter-rouge">외부 라이브러리 금지</code>, <code class="language-plaintext highlighter-rouge">쓰레드 활용 금지</code> 와 같이 제약사항이 많다. 여기에서 그쳤다면 정말 좋았겠지만, 안타깝게도 <code class="language-plaintext highlighter-rouge">소스코드의 용량 제한</code>이 있다. 무려 <code class="language-plaintext highlighter-rouge">약 30kb</code>이상 넘는 코드를 제출 할 경우 저지 시스템 레벨에서 제출을 금하는 것이다.</p> <p>그렇기 때문에 직접 코드를 구현하여야하며, <code class="language-plaintext highlighter-rouge">30kb</code>가 넘지 않는 코드를 작성해야한다는 것이다.</p> <h1 id="시스템-구조-설계">시스템 구조 설계</h1> <p>필자의 경우에는 <code class="language-plaintext highlighter-rouge">MNIST</code>의 이미지가 입력이 되었을 때, 숫자 정보를 추출하기 위해서 딥 러닝 모델을 활용하였다. 따라서 전체적인 시스템은 크게 3가지의 파트로 나눠진다.</p> <ol> <li>인공지능 모델 : 파이썬과 텐서플로우를 통해 <code class="language-plaintext highlighter-rouge">MNIST</code>의 이미지가 어떠한 숫자인지 판별하는 인공지능 모델을 생성</li> <li>모델의 가중치를 C++ 코드로 변환 : 텐서플로우를 통해 가중치 정보를 <code class="language-plaintext highlighter-rouge">JinJa2</code> 템플릿 엔진을 통해 C++ 코드 생성</li> <li>저지 사이트에 제출 가능한 C++ 단일 파일 생성 : CMakeLists를 통해 <code class="language-plaintext highlighter-rouge">MNIST Inference Engine</code> 바이너리 생성</li> </ol> <h2 id="인공지능-모델-생성">인공지능 모델 생성</h2> <p>인공지능 모델을 학습 하는 것은 정말 쉽고 간단하다. 이를 증명하듯이, <code class="language-plaintext highlighter-rouge">텐서플로우</code>나 <code class="language-plaintext highlighter-rouge">파이토치</code> 사이트에서 기본적인 학습용 코드를 제공하고 있다. <a href="https://www.tensorflow.org/datasets/keras_example?hl=ko">[학습용 코드]</a>. 하이퍼 링크로 건 곳은 <code class="language-plaintext highlighter-rouge">Tensorflow</code>에서 <code class="language-plaintext highlighter-rouge">MNIST</code>를 학습용으로 만든 것이며, 필자가 사용한 인공지능 모델을 기반으로 만든 것이다.</p> <p>저지 사이트의 한계점으로 인하여, (1x28x28) 이미지를 그대로 <code class="language-plaintext highlighter-rouge">Dense</code>나 <code class="language-plaintext highlighter-rouge">Convolution</code> 으로 만들게 될 경우 생성되는 <code class="language-plaintext highlighter-rouge">weight</code>의 양으로 인하여 <code class="language-plaintext highlighter-rouge">30kb</code>가 초과하였기 때문에, 어쩔 수 없이 이미지를 <code class="language-plaintext highlighter-rouge">Downscaling</code> 한 뒤 <code class="language-plaintext highlighter-rouge">Dense</code>로 연산을 수행하도록 하였다. 이때, <code class="language-plaintext highlighter-rouge">Downscaling</code>을 조금 더 직관적이고 신경망 모델에서 동작한다는 느낌을 주기 위해 <code class="language-plaintext highlighter-rouge">Average Pooling</code>로 표현하였다. 그 이후에는 이 글을 읽는 모두가 다 알 것이라 예상하듯이, 평탄화하고, <code class="language-plaintext highlighter-rouge">Dense</code>와 <code class="language-plaintext highlighter-rouge">Activate</code> 함수로 대충 연결해 주었다.</p> <p>자세한 코드는 <a href="https://github.com/Piorosen/implement-mnist/blob/main/scripts/train_with_save.py">[Train model and Save H5]</a> 에 기술 되어져 있다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Input (1 x 28 x 28) -&gt; 
 Average Pooling (1 x 7 x 7) -&gt;
 Flatten (1 x 49) -&gt;
 Dense (1 x 49 x 30) -&gt;
 ReLu (Activate) -&gt;
 Dense (1 x 30 x 10) -&gt;
 Output (1 x 10) 
</code></pre></div></div> <h2 id="모델-가중치를-c-코드로-변환">모델 가중치를 C++ 코드로 변환</h2> <p>H5 모델과 신경망 모델 구조에 대한 정보를 가지고 있으므로, 이를 <code class="language-plaintext highlighter-rouge">numpy</code>나 출력 가능한 형태로만 만들 수 있다면 무엇이든지 만사 OK이다. 그 이유로는 아래와 같이 미리 만들어놓은 <code class="language-plaintext highlighter-rouge">template.hpp</code> 코드가 있고, 이를 <code class="language-plaintext highlighter-rouge">JinJa2</code> Template Engine이 ``에 값을 채워넣어 줄 것이기 때문이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">49</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">30</span><span class="o">&gt;</span> <span class="n">dense1_weight</span> <span class="p">{</span>  <span class="p">};</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">30</span><span class="o">&gt;</span> <span class="n">dense1_bias</span> <span class="p">{</span>  <span class="p">};</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">30</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">dense2_weight</span> <span class="p">{</span>  <span class="p">};</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">dense2_bias</span> <span class="p">{</span>  <span class="p">};</span>
</code></pre></div></div> <p>먼저 <code class="language-plaintext highlighter-rouge">JinJa2</code> 를 모르는 사람이 있을지도 몰라, 간단하게 설명하자면, 반복문, 조건문, 값 치환 등이 가능한 Template 엔진 중 하나이다. 필자는 잘 모르겠지만, 백엔드 개발에서 <code class="language-plaintext highlighter-rouge">NodeJS</code>나 <code class="language-plaintext highlighter-rouge">DJango</code>에서 HTML 파일 Serving할 때 많이 쓰인다고 본적이 있다.</p> <p>무튼, 바로 본론으로 들어가자면 <a href="https://github.com/Piorosen/implement-mnist/blob/main/scripts/gen_param_for_cpp.py">[Convert H5 to CPP]</a> 코드에서 <code class="language-plaintext highlighter-rouge">JinJa2</code> 템플릿을 렌더링을 하면서 C++ 코드를 생성하는 것을 볼 수 있다.</p> <p><img src="/assets/img/post/2024-06-08-01.png" alt=""/></p> <p>그러면 아래와 같은 C++ 코드를 결과물로써 얻어 볼 수가 있다.</p> <p><img src="https://github.com/Piorosen/implement-mnist/blob/main/resources/img2.png?raw=true" alt=""/></p> <h2 id="저지-사이트에-제출-가능한-c-단일-파일-생성">저지 사이트에 제출 가능한 C++ 단일 파일 생성</h2> <p>이제 Keras의 H5 파일의 가중치 데이터를 모두 C++ 코드 영역으로 가지고 왔다면 더 이상 <code class="language-plaintext highlighter-rouge">tensorflow</code>나 <code class="language-plaintext highlighter-rouge">keras</code>, <code class="language-plaintext highlighter-rouge">h5</code>와 같은 종속성은 모두 필요 없으며 이제 순수 C++ 형태로 구성이 된다.</p> <p>C++ 의 특성을 활용해서 <code class="language-plaintext highlighter-rouge">#include "weights.txt"</code> 하도록 하여 원하는 지점에 가중치 파일을 삽입하도록 하였다. 필자의 경우, 가중치 데이터를 프로그램이 메모리에 적재될 때 함께 메모리에 적재되도록 하기 위해서 전역 변수로, <code class="language-plaintext highlighter-rouge">constexpr static std::array&lt;&gt;</code>로 정의하였다.</p> <p><img src="/assets/img/post/2024-06-08-02.png" alt=""/></p> <p>이후로는 모두가 다 알다 싶이 <code class="language-plaintext highlighter-rouge">g++</code>이나 <code class="language-plaintext highlighter-rouge">msvc</code>, <code class="language-plaintext highlighter-rouge">mingw</code>, <code class="language-plaintext highlighter-rouge">clang++</code>으로 빌드를 수행하면 되며, 저지 사이트에 제출하고 싶다면 메뉴얼하게 직접 코드를 <code class="language-plaintext highlighter-rouge">Copy&amp;Paste</code> 하면 된다. 그러면 <code class="language-plaintext highlighter-rouge">MNIST</code> 추론이 가능한 실행 가능한 바이너리가 쨔쟌 하고 생성이 된다.</p> <h1 id="재현성-필요하다면">재현성 (필요하다면)</h1> <p>딥 러닝의 대부분은 랜덤성으로 다뤄지므로 재현성이 매우 중요하다고 필자는 생각한다. 또한, 필자는 글 보다는 코드를 보면서 코드에 대한 근거나 이유에 생각하는 것이 편하기 때문에 코드를 쉽게 따라 할 수 있도록 만들었다.</p> <p>레포지토리와 빌드 과정에 대해서 간략하게나마 기술한다.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/Piorosen/implement-mnist.git
<span class="nv">$ </span><span class="nb">cd </span>implement-mnist
<span class="nv">$ </span><span class="nb">chmod</span> +x ./scripts/run.sh <span class="c"># setting and build by docker</span>
<span class="nv">$ </span>./scripts/run.sh <span class="nt">--all</span> <span class="c"># the number of MNIST dataset from train dataset in tensorflow dataset, nearly 100.</span>
</code></pre></div></div>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Develop"/><category term="mnist"/><category term="keras"/><category term="h5"/><category term="c++"/><category term="cpp"/><category term="deploy"/><category term="compile"/><category term="python"/><category term="tensorflow"/><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">Let’s Encrypt를 이용하여 시놀로지에 SSL 적용 (w/ Certbot)</title><link href="https://blog.udon.party/blog/2024/lets-encrypt-on-synology-with-txt-authorization/" rel="alternate" type="text/html" title="Let’s Encrypt를 이용하여 시놀로지에 SSL 적용 (w/ Certbot)"/><published>2024-05-07T00:00:00+00:00</published><updated>2024-05-07T00:00:00+00:00</updated><id>https://blog.udon.party/blog/2024/lets-encrypt-on-synology-with-txt-authorization</id><content type="html" xml:base="https://blog.udon.party/blog/2024/lets-encrypt-on-synology-with-txt-authorization/"><![CDATA[<h1 id="개요">개요</h1> <p>우선 본 내용은 필자가 까먹거나 다시 리마인드용으로 남기기 위해서, 또한 한번 더 정리해서 기록할 겸 작성한 포스팅이므로, 원글을 확인하고자 한다면 <a href="https://velog.io/@atmost1815/Synology%EC%97%90%EC%84%9C-Wildcard-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%9E%90%EB%8F%99-%EA%B0%B1%EC%8B%A0%ED%95%98%EA%B8%B0">[Here]</a> 을 참조하길 바란다. 또한, 해당 내용은 Lets Encrypt를 활용하여 SSL 인증서를 발급과 동시에, 와일드 카드 인증서를 발급을 받을 것이다. 또한, 누구나 쉽게 따라할 수 있도록 만들고자 한다. 다만, 기본 선행적인 지식이 필요하다.</p> <ol> <li>Secure SHell (SSH)</li> <li>Docker</li> <li><code class="language-plaintext highlighter-rouge">Readable</code> Shell Script</li> <li><code class="language-plaintext highlighter-rouge">if possible</code> for DNS Service, Cloudflare</li> </ol> <p>크게 3가지의 개념이 필요하며, 이것만 충분히 가능하다면 쉽게 해당 글을 따라하여 <code class="language-plaintext highlighter-rouge">Lets Encrypt</code>의 인증서를 발급받고, 사용할 수 있을것이라 예상이 된다. 원글의 작성자의 경우에는 <code class="language-plaintext highlighter-rouge">Shell</code> 스크립트와 <code class="language-plaintext highlighter-rouge">Docker</code> 기반으로 작성이 되어져 있기 때문에 처음 사용한다면 익숙하지 않아 어려움을 겪을수가 있다. 따라서 필자는 가능하다면 원형을 훼손시키지 않은채 쉽게 쓰도록 약간의 변형을 거칠 것이다.</p> <h1 id="목차">목차</h1> <ol> <li>(생략) Install Docker on Synology</li> <li>(생략) Connect to Synology Server via SSH</li> <li>자동화를 작업하기 위한 작업 영역 세팅</li> <li>Let’s Encrypt을 위한 도메인 주소 소유 인증 절차</li> <li>발급한 인증서를 시놀로지 시스템에 적용</li> <li>자동 갱신 설정</li> </ol> <h2 id="3-자동화를-작업하기-위한-작업-영역-세팅">3. 자동화를 작업하기 위한 작업 영역 세팅</h2> <p>필자의 경우에는 <code class="language-plaintext highlighter-rouge">main</code> 이라는 저장소 안에 <code class="language-plaintext highlighter-rouge">ssl</code> 이라는 폴더를 생성하여 진행하였다. 즉 터미널로 접근한다면 <code class="language-plaintext highlighter-rouge">/volume1/main/ssl/</code> 이라는 작업 공간으로 잡았다는 것을 의미한다. 터미널로 이용해서 직접 폴더를 생성하여 진행하여도 무관하다. 즉, 아래와 같은 터미널 명령어를 수행하여도 동일한 결과를 나타낸다는 것을 의미한다. 당연하게도, <code class="language-plaintext highlighter-rouge">$</code> 맨 앞에 나타내는 달러의 의미는 리눅스의 환경에서 터미널 명령어를 수행한다라는 암묵적인 규칙중 하나이다. (정말 쓸모 없는 지식이지만 리눅스에서는 <code class="language-plaintext highlighter-rouge">$</code>, 유닉스 환경[macOS] 의 경우에는 <code class="language-plaintext highlighter-rouge">%</code> 이다. 따로 의미는 정말 없다. 그냥 컴퓨터가 처음 나왔을 때, 논문에서 명령어를 직관적으로 구별하기 위해서 나온 것이라 보면 편하다.)</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> /volume1/main/ssl
</code></pre></div></div> <p><img src="/assets/img/post/2024-05-07-01.png" alt=""/></p> <h2 id="4-lets-encrypt을-위한-도메인-주소-소유-인증-절차">4. Let’s Encrypt을 위한 도메인 주소 소유 인증 절차</h2> <p>폴더를 생성하였다면, <code class="language-plaintext highlighter-rouge">SSH(터미널)</code>을 통해 <code class="language-plaintext highlighter-rouge">cd /volume1/main/ssl</code> 로 작업 영역으로 이동 한다. 그 이후에 <code class="language-plaintext highlighter-rouge">vim</code>이나 <code class="language-plaintext highlighter-rouge">nano</code>를 통해 아래의 코드를 추가한다. 파일명은 따로 신경쓰진 않지만, <code class="language-plaintext highlighter-rouge">certbot.sh</code> 이나 확장자 명이 없어도 무관하다. 편리하게 이름을 작성하면 된다.</p> <p>생성 한 뒤에 반드시 확인해야하는 내용이 2가지가 있다.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">WORK_DIRECTORY</code> 가 반드시 <code class="language-plaintext highlighter-rouge">/volume1/main/ssl</code> 인지 확인할 것이다. 현재 기본값인 <code class="language-plaintext highlighter-rouge">$(pwd)</code>는 현재 디렉토리를 기준으로 하므로, <code class="language-plaintext highlighter-rouge">cd /volume1/main/ssl</code> 란 명령어를 수행하였다면 생략하여도 무관하다.</p> </li> <li> <p>현재 소유중인 도메인 주소가 <code class="language-plaintext highlighter-rouge">example.com</code>이 맞는지 확인한다. 필자의 경우에는 <code class="language-plaintext highlighter-rouge">udon.party</code>를 소유중이므로, <code class="language-plaintext highlighter-rouge">DOMAIN_URL=udon.party</code>라 작성하였다. (도메인 주소는 어차피 해킹 대상이나, 숨겨야하는 정보가 아니므로 공개한다., 어차피 블로그의 주소가 <code class="language-plaintext highlighter-rouge">udon.party</code> 이므로 문제가… 없다.)</p> </li> </ol> <p>그 이후에는 <code class="language-plaintext highlighter-rouge">./certbot.sh</code> 또는 <code class="language-plaintext highlighter-rouge">./{독자가 생성한 파일명으로}</code> 으로 실행한다. 만약 오류가 생긴다면, 실행 권한이 부족한 것이므로 <code class="language-plaintext highlighter-rouge">chmod +x {독자가 생성한 파일명}</code> 또는 <code class="language-plaintext highlighter-rouge">chmod +x certbot.sh</code>으로 파일에 권한을 부여하고, 다시 실행해 본다.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nv">CONTAINER_NAME</span><span class="o">=</span>certbot <span class="c"># 변경하지 않아도 무관한 영역</span>
<span class="nv">WORK_DIRECTORY</span><span class="o">=</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>  <span class="c"># 자동화를 작업하기 위한 작업 영역 세팅할 경로, 그것이 아니라면 현재 디렉토리를 기반으로 수행함.</span>
<span class="nv">DOMAIN_URL</span><span class="o">=</span>example.com <span class="c"># 해당 글을 읽고 있는 사람이 가지고 있는 도메인 주소</span>

docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="se">\</span>
  <span class="nt">--pull</span><span class="o">=</span>always <span class="se">\</span>
  <span class="nt">--name</span><span class="o">=</span><span class="k">${</span><span class="nv">CONTAINER_NAME</span><span class="k">}</span> <span class="se">\</span>
  <span class="nt">-e</span> <span class="s2">"TZ=Asia/Seoul"</span> <span class="se">\</span>
  <span class="nt">-v</span> <span class="s2">"</span><span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span><span class="s2">/etc:/etc/letsencrypt"</span> <span class="se">\</span>
  <span class="nt">-v</span> <span class="s2">"</span><span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span><span class="s2">/var:/var/lib/letsencrypt"</span> <span class="se">\</span>
    certbot/certbot certonly <span class="se">\</span>
  <span class="nt">-d</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOMAIN_URL</span><span class="k">}</span><span class="s2">"</span> <span class="se">\</span>
  <span class="nt">-d</span> <span class="s2">"*.</span><span class="k">${</span><span class="nv">DOMAIN_URL</span><span class="k">}</span><span class="s2">"</span> <span class="se">\</span>
  <span class="nt">--manual</span> <span class="nt">--preferred-challenges</span> dns <span class="nt">--server</span> https://acme-v02.api.letsencrypt.org/directory
</code></pre></div></div> <p>그 뒤에는 터미널 창에 무언가의 내용이 출력이 되게 되는데, 간단한 영어 해석과 <code class="language-plaintext highlighter-rouge">DNS</code>에 대한 개념이 있다면 쉽게 따라할 수 있다. 그렇지만 최대한 해석을 해보자면</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /var/log/letsencrypt/letsencrypt.log 에 로그 파일을 저장함.</span>
Saving debug log to /var/log/letsencrypt/letsencrypt.log
<span class="c"># udon.party 인증 요청</span>
Requesting a certificate <span class="k">for </span>udon.party

-
<span class="c"># DNS에 이름은 _acme-challenge인 TXT 레코드를 추가하세요.</span>
Please deploy a DNS TXT record under the name:
_acme-challenge.udon.party. with the following value:

<span class="c"># 그리고 값을 BAvL0h4rtSmoS21f0zrXJ0PnCc0tVJG9Er0YpIyt931 으로 지정하세요.</span>
BAvL0h4rtSmoS21f0zrXJ0PnCc0tVJG9Er0YpIyt931

<span class="c"># 게속하기 이전에, TXT 레코드가 정상적으로 추가가 되었는지 확인하세요! 이는 DNS Provider가 추가를 해줘야지만 계속할 수 있습니다. 그렇게 때문에 시간이 걸릴 수 있습니다. 그리고 위의 TXT 레코드를 추가하고 정상적으로 배포가 되었는지 확인하기 위해서는 `https://toolbox.googleapps.com/apps/dig/#TXT/_acme-challenge.udon.party.` 에서 확인하세요.</span>
Before continuing, verify the TXT record has been deployed. Depending on the DNS provider, this may take some <span class="nb">time</span>, from a few seconds to multiple minutes. You can check <span class="k">if </span>it has finished deploying with aid of online tools, such as the Google Admin Toolbox: https://toolbox.googleapps.com/apps/dig/#TXT/_acme-challenge.on.party.
Look <span class="k">for </span>one
or more bolded line<span class="o">(</span>s<span class="o">)</span> below the line
<span class="s1">'¡ANSWER'</span><span class="nb">.</span> It should show the
values<span class="o">)</span> you<span class="s1">'ve just added.
Press Enter to Continue
</span></code></pre></div></div> <p>요약하자면, 뭔가 모르는 TXT 레코드를 DNS 서버에 등록해야한다는 의미이다. 그래서 이를 조금 더 쉽게 표현하자면 아래의 그림 순으로 터미널 창에 텍스트가 나타나게 되고, <code class="language-plaintext highlighter-rouge">Cloudflare</code>에 접속하여 아래와 같이 <code class="language-plaintext highlighter-rouge">Name</code>과, <code class="language-plaintext highlighter-rouge">Content</code>에 값을 넣고 추가하면 된다.</p> <p>그리고, <code class="language-plaintext highlighter-rouge">DNS Provider(=Cloudflare)</code>에서 추가하더라도, 바로 다음으로 진행하면 안되고, 터미널 창에서 나온 <code class="language-plaintext highlighter-rouge">URL</code> 주소를 클릭하여 반드시 정상적으로 추가가 되었는지 확인해야한다.</p> <p><img src="/assets/img/post/2024-05-07-02.png" alt=""/> <img src="/assets/img/post/2024-05-07-03.png" alt=""/></p> <p>이 과정을 총 2번 진행하므로, 2번 진행하면 <code class="language-plaintext highlighter-rouge">/volume1/main/ssl</code> 폴더에 <code class="language-plaintext highlighter-rouge">etc</code>와 <code class="language-plaintext highlighter-rouge">var</code> 폴더가 생성이 되고, <code class="language-plaintext highlighter-rouge">./etc/archive/udon.party</code> 란 폴더에 4개의 파일이 생성이 되었다면 인증 절차 과정은 모두 끝나게 된 것이다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cert.pem
chain.pem
fullchain.pem
privkey.pem
</code></pre></div></div> <h2 id="5-발급한-인증서를-시놀로지-시스템에-적용">5. 발급한 인증서를 시놀로지 시스템에 적용</h2> <p><code class="language-plaintext highlighter-rouge">/volume1/main/ssl</code> 폴더를 기준으로 <code class="language-plaintext highlighter-rouge">./etc/archive/udon.party</code>에 접속한다면, 4개의 파일들 중에서 아래의 3개를 다운로드 받는다. <code class="language-plaintext highlighter-rouge">cert.pem</code>, <code class="language-plaintext highlighter-rouge">chain.pem</code>, <code class="language-plaintext highlighter-rouge">privatekey.pem</code>을 3개를 다운로드 받는다. 다운로드 받는 방법은 <code class="language-plaintext highlighter-rouge">scp</code>를 이용하거나, <code class="language-plaintext highlighter-rouge">ftp</code>를 이용하거나, <code class="language-plaintext highlighter-rouge">dsfile on synology</code> 를 이용하여 다운로드 받도록 한다.</p> <p>그 이후에는, 시놀로지에서 <code class="language-plaintext highlighter-rouge">기본 인증서로 설정</code> 체크박스를 선택하고, 인증서를 가져오기 하면 된다. 그리고, 개인키는 <code class="language-plaintext highlighter-rouge">private.pem</code>, 인증서는 <code class="language-plaintext highlighter-rouge">cert.pem</code>, 중간 인증서는 <code class="language-plaintext highlighter-rouge">chain.pem</code>으로 지정을 하고 확인을 누르면 된다.</p> <p>그러면 모든것이 끝나게 된 것이다. 그러나 한가지 마지막 스텝이 남아있다. Lets Encrypt는 90일 동안만 인증서가 유지가 되고, 30일이 지나야지 갱신을 할 수 있다. 그렇기 때문에, 매달 1번씩이라도 라이센스를 갱신하도록 만들어야 한다는 것이다.</p> <p>그래서 우리는 이를 리눅스에 있는, 또는 시놀로지의 기능으로 제공되는 <code class="language-plaintext highlighter-rouge">cron</code> 또는 <code class="language-plaintext highlighter-rouge">스케줄링</code> 기능을 이용하여 이를 자동화 할 에정이다.</p> <p><img src="/assets/img/post/2024-05-07-04.png" alt=""/> <img src="/assets/img/post/2024-05-07-05.png" alt=""/></p> <h2 id="6-자동-갱신-설정">6. 자동 갱신 설정</h2> <p>우선, 먼저 자동화를 하기 위해서 2가지의 선행이 필요하다.</p> <h3 id="1-synology의-인증서-저장-경로를-도커-경로와-매칭하기">1. Synology의 인증서 저장 경로를 도커 경로와 매칭하기</h3> <p>그냥 아래의 순서를 따라 입력하면 된다.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-i</span>

<span class="nv">$ WORK_DIRECTORY</span><span class="o">=</span>/volume1/main/ssl <span class="c"># example</span>
<span class="nv">$ DOMAIN</span><span class="o">=</span>example.com <span class="c"># example</span>

<span class="nv">$ DATA</span><span class="o">=</span><span class="sb">`</span><span class="nb">cat</span> /usr/syno/etc/certificate/_archive/DEFAULT<span class="sb">`</span>
<span class="nv">$ </span><span class="nb">cd</span> /usr/syno/etc/certificate/_archive/<span class="k">${</span><span class="nv">DATA</span><span class="k">}</span>
<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-rf</span> <span class="k">*</span> <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">ln</span> <span class="nt">-s</span> <span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span>/etc/live/<span class="k">${</span><span class="nv">DOMAIN</span><span class="k">}</span>/cert.pem cert.pem <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">ln</span> <span class="nt">-s</span> <span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span>/etc/live/<span class="k">${</span><span class="nv">DOMAIN</span><span class="k">}</span>/chain.pem chain.pem <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">ln</span> <span class="nt">-s</span> <span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span>/etc/live/<span class="k">${</span><span class="nv">DOMAIN</span><span class="k">}</span>/fullchain.pem fullchain.pem <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">ln</span> <span class="nt">-s</span> <span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span>/etc/live/<span class="k">${</span><span class="nv">DOMAIN</span><span class="k">}</span>/privkey.pem privkey.pem
</code></pre></div></div> <p>그러면, 이제 <code class="language-plaintext highlighter-rouge">cerbot</code>을 이용한 자동 갱신을 쉘 코드를 작성하고, 실행만 한다면 이제 끝나게 됩니다. 여기서, 클라우드 플레어를 사용중이라면, <code class="language-plaintext highlighter-rouge">Cloudflare</code>의 API Token을 추가하여 자동화 시킬 수도 있습니다. 자세한 내용은 <a href="https://certbot-dns-cloudflare.readthedocs.io/en/stable/#credentials">[클라우드 플레어와 Certbot 연동]</a>을 확인하시면 됩니다.</p> <p>예시로는 아래의 코드와 같습니다.</p> <p><code class="language-plaintext highlighter-rouge">${WORK_DIRECTORY}/etc/cloudflare.ini</code> 을 생성하고, <code class="language-plaintext highlighter-rouge">dns_cloudflare_api_token = &lt;API Token&gt;</code> 내용을 기입하시면 됩니다.</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">WORK_DIRECTORY</span><span class="o">=</span>/volume1/main/ssl <span class="c"># example</span>
<span class="nv">CONTAINER_NAME</span><span class="o">=</span>certbot

docker run <span class="nt">--rm</span> <span class="se">\</span>
  <span class="nt">--pull</span><span class="o">=</span>always <span class="se">\</span>
  <span class="nt">--name</span> <span class="k">${</span><span class="nv">CONTAINER_NAME</span><span class="k">}</span> <span class="se">\</span>
  <span class="nt">-e</span> <span class="s2">"TZ=Asia/Seoul"</span> <span class="se">\</span>
  <span class="nt">-v</span> <span class="s2">"</span><span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span><span class="s2">/etc:/etc/letsencrypt"</span> <span class="se">\</span>
  <span class="nt">-v</span> <span class="s2">"</span><span class="k">${</span><span class="nv">WORK_DIRECTORY</span><span class="k">}</span><span class="s2">/var:/var/lib/letsencrypt"</span> <span class="se">\</span>
  certbot/dns-cloudflare renew <span class="se">\</span>
  <span class="nt">--dns-cloudflare</span> <span class="se">\</span>
  <span class="nt">--dns-cloudflare-credentials</span> <span class="s1">'/etc/letsencrypt/cloudflare.ini'</span> <span class="se">\</span>
  <span class="nt">--dns-cloudflare-propagation-seconds</span> 60
</code></pre></div></div> <p>마지막으로, 30일 주기의 <code class="language-plaintext highlighter-rouge">Cron</code>은 시놀로지에서 <code class="language-plaintext highlighter-rouge">제어판</code> -&gt; <code class="language-plaintext highlighter-rouge">서비스</code> -&gt; <code class="language-plaintext highlighter-rouge">작업 스케줄러</code> 에서 등록하고, 위의 쉘 스크립트를 추가하시면 됩니다.</p> <h2 id="결론">결론</h2> <p>정말, 힘든 과정을 거치게 되었고, 기존에는 맘 편하게 <code class="language-plaintext highlighter-rouge">DDNS</code>를 이용하거나 <code class="language-plaintext highlighter-rouge">Cloudflare</code>의 <code class="language-plaintext highlighter-rouge">Proxy</code> 서비스를 이용하여 무료 <code class="language-plaintext highlighter-rouge">SSL</code> 인증서를 기반으로 진행하였었습니다. 그러나 직접 <code class="language-plaintext highlighter-rouge">Let's Encrypt</code>를 발급 받아서 사용하니 이제 조금,,, 이상한 <code class="language-plaintext highlighter-rouge">DDNS</code>의 URL 주소를 사용하지 않고 자기 자신만의 도메인을 기반으로 사용할 수 있다는것이 조금 주소가 더 이뻐진것 같아 기분이 좋습니다.</p> <p>큰 의미없이 그냥 정말 단순히 기분이나 뽐내기용이다보니, 기분은 좋습니다. 그리고, <code class="language-plaintext highlighter-rouge">Cloudflare</code>의 <code class="language-plaintext highlighter-rouge">Proxy</code> 서비스는 특정 포트만 가능하다는 단점으로 인해서 <code class="language-plaintext highlighter-rouge">WebDAV</code> 서비스를 이용하기에는 꽤나 많은 어려움이 있었는데, 그런 것이 없어지니 조금 편한것 같기도 합니다.</p>]]></content><author><name>piorosen</name></author><category term="Blogging"/><category term="Develop"/><category term="lets-encrypt"/><category term="synology"/><category term="ssl"/><category term="cloudflare"/><category term="txt"/><category term="certbot"/><summary type="html"><![CDATA[개요]]></summary></entry></feed>