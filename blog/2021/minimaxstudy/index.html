<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Minimax 알고리즘 공부 및 내용 점검 | JooHyoung Cha </title> <meta name="author" content="JooHyoung Cha"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://blog.udon.party/blog/2021/minimaxstudy/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">JooHyoung</span> Cha </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Minimax 알고리즘 공부 및 내용 점검</h1> <p class="post-meta"> Created in June 26, 2021 by piorosen </p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a>   ·   <a href="/blog/tag/algorithm"> <i class="fa-solid fa-hashtag fa-sm"></i> algorithm</a>   <a href="/blog/tag/ai"> <i class="fa-solid fa-hashtag fa-sm"></i> ai</a>   <a href="/blog/tag/minimax"> <i class="fa-solid fa-hashtag fa-sm"></i> minimax</a>   <a href="/blog/tag/gomoku"> <i class="fa-solid fa-hashtag fa-sm"></i> gomoku</a>   ·   <a href="/blog/category/blogging"> <i class="fa-solid fa-tag fa-sm"></i> Blogging</a>   <a href="/blog/category/develop"> <i class="fa-solid fa-tag fa-sm"></i> Develop</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="개요">개요</h1> <p>교수님께서 DQN(Deep Q-Network) 와 같이 Q 함수를 이용하여 강화 학습을 이용하여 오목 프로그램을 만들어 보자고 하셨다. 그렇지만 Tensorflow나 PyTorch와 같은 딥러닝 라이브러리를 사용하는것이 아닌 직접 코드를 작성 해서 만들어 보자고 하셨다. 그래서 게임에 적용할 게임 인공지능에 대해서 공부를 하게 되었다. 최종 목표로는 강화 학습을 직접 구현 해보고, 오목 인공지능을 만들어 보는 것이다. 인공지능에 대해서 공부를 하면서 minimax 알고리즘 이라는 최소극대화 알고리즘 을 공부하게 되었다.</p> <h1 id="minimax-알고리즘-이란">Minimax 알고리즘 이란?</h1> <p>Minimax 알고리즘은 현재 상태를 입력 받았을 때, 점수를 나타낼 함수가 반드시 꼭 필요하다. 그리고 Tree란 개념이 사용이 되므로 Depth, 트리의 깊이 변수도 필요하다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Work
</span><span class="mf">1.</span> <span class="n">현재</span> <span class="n">게임</span> <span class="n">보드</span> <span class="n">상태의</span> <span class="n">점수를</span> <span class="n">구함</span><span class="p">.</span>
<span class="mf">2.</span> <span class="n">다음에</span> <span class="n">둘</span> <span class="n">수</span> <span class="n">있는</span> <span class="n">모든</span> <span class="n">수를</span> <span class="n">분기</span><span class="p">(</span><span class="n">Branch</span><span class="p">)</span> <span class="n">한</span> <span class="n">뒤</span> <span class="n">각</span> <span class="n">분기의</span> <span class="n">점수를</span> <span class="n">구함</span><span class="p">.</span>
<span class="mf">3.</span> <span class="sh">'</span><span class="s">2번</span><span class="sh">'</span><span class="n">에서</span> <span class="n">분기</span> <span class="n">했던</span> <span class="n">수를</span> <span class="n">또</span> <span class="n">다시</span> <span class="n">한번</span> <span class="n">더</span> <span class="n">분기</span> <span class="n">한</span> <span class="n">뒤</span> <span class="n">점수를</span> <span class="n">구함</span><span class="p">.</span>
<span class="mf">4.</span> <span class="n">N번</span> <span class="n">반복</span> <span class="n">함</span><span class="p">.</span>
<span class="mf">5.</span> <span class="n">Minimax</span> <span class="n">알고리즘으로</span> <span class="n">최소극대화</span> <span class="n">점수를</span> <span class="n">구함</span><span class="p">.</span>
</code></pre></div></div> <p>Minimax 알고리즘은 2명이서 즐길 수 있는 게임에서 주로 사용이 된다. 그리고 Minimax 알고리즘에서 최소극대화를 조금 알기 쉽게 표현을 하자면</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">1.</span> <span class="n">나의</span> <span class="n">턴일</span> <span class="n">때</span> <span class="n">최고의</span> <span class="n">수를</span> <span class="n">두어야</span> <span class="n">하는</span> <span class="n">상황일</span> <span class="n">때</span>
<span class="mf">2.</span> <span class="n">상대방</span> <span class="n">턴일</span> <span class="n">때</span> <span class="n">최고의</span> <span class="n">수를</span> <span class="n">두어야</span> <span class="n">하는</span> <span class="n">상황일</span> <span class="n">때</span>
<span class="n">총</span> <span class="mi">2</span><span class="n">가지의</span> <span class="n">상황이</span> <span class="n">있다</span><span class="p">.</span>

<span class="n">나의</span> <span class="n">턴일</span> <span class="n">때는</span> <span class="n">최고의</span> <span class="n">점수를</span> <span class="n">가지는</span> <span class="n">수를</span> <span class="n">두어야</span> <span class="n">하고</span><span class="p">,</span> <span class="n">상대방</span> <span class="n">턴일</span> <span class="n">때도</span> <span class="n">마찬가지로</span> <span class="n">이기기</span> <span class="n">위해서</span> <span class="n">최고의</span> <span class="n">점수를</span> <span class="n">가지는</span> <span class="n">수를</span> <span class="n">두게</span> <span class="n">될</span> <span class="n">것이다</span><span class="p">.</span>
<span class="n">이</span> <span class="n">때</span> <span class="n">나의</span> <span class="n">턴이</span> <span class="n">최고의</span> <span class="n">점수를</span> <span class="n">가지면서</span> <span class="n">상대방도</span> <span class="n">최고의</span> <span class="n">점수를</span> <span class="n">가지게</span> <span class="n">될</span> <span class="n">때</span> <span class="n">나의</span> <span class="n">턴의</span> <span class="n">점수가</span> <span class="n">최대한</span> <span class="n">높은</span> <span class="n">수를</span> <span class="n">두는</span> <span class="n">알고리즘</span> <span class="n">이다</span><span class="p">.</span>
</code></pre></div></div> <h1 id="코드-설명">코드 설명</h1> <p>여기서 코드를 설명 할 때 모두 전부 구현이 된 것이 아닌, 이해를 하기 위해서 일부만 구현을 하였습니다. 예를 들어 board::getScore 함수는 구현하지 않았습니다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 현재 상태를 표현이 가능한 보드판.</span>
<span class="k">struct</span> <span class="nc">board</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">map</span><span class="p">[</span><span class="mi">13</span><span class="p">][</span><span class="mi">13</span><span class="p">];</span>
    
    <span class="c1">// 현재 보드 상태에 따른 스코어 점수.</span>
    <span class="kt">int</span> <span class="n">getScore</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 트리 구성을 위해서 node 를 만듬.</span>
<span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
    <span class="n">board</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div> <p>여기서 현재 보드 상태와 보드 상태를 분기가 가능하게끔 (Tree로 나타내기 위한) Node 구조체를 만들었다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 현재 보드 상태에서 착수가 가능한 상태를 계산 함.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">canNextStep</span><span class="p">(</span><span class="n">board</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span><span class="p">();</span>
    
    <span class="c1">// 단순 10번 반복한 데이터를 넣음. 여기서 보드 데이터와 착수 위치 데이터 까지 같이 넣을 수 있음.</span>
    <span class="c1">// 그렇게 된다면 board를 반환 하는것이 아닌 point로 또한 가능 함.</span>
    <span class="c1">// 여기서 오목이면 렌주룰과 같은 룰 체크 기능을 넣을 수 있음.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">node</span><span class="p">();</span>
        <span class="n">n</span><span class="p">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">board</span><span class="p">();</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 분기 가능한 보드를 모두 분기 함.</span>
<span class="n">node</span> <span class="nf">makeRootNode</span><span class="p">(</span><span class="n">board</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">curDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">();</span>
    
    <span class="c1">// depth 변수 만큼 착수 지점을 분기 함.</span>
    <span class="n">parent</span><span class="p">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">parent</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">canNextStep</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">curDepth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">parent</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parent</span><span class="p">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">makeRootNode</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">current</span><span class="p">,</span> <span class="n">curDepth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>여기서 트리 구조로 N-Depth 만큼 착수를 할 가능성이 있는 모든 수를 분기 하여 트리 구조로 만든다. 트리 구조로 만들게 되었다고 하면 여기서 minimax 알고리즘을 이용하여 나와 상대방이 모두 최고의 수를 두었을 때 내가 가질 수 있는 최고의 수를 내야 한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">node</span> <span class="nf">minimax</span><span class="p">(</span><span class="n">node</span> <span class="n">root</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isMax</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// isMax란 변수로 최대 최소를 구함.</span>
    <span class="c1">// isMax가 false이면 현재 보드 분기 목록 중에서 점수가 가장 낮은 게임 판을 구함.</span>
    <span class="c1">// isMax가 true이면 그 와 반대로 점수가 가장 높은 게임 판을 구함.</span>
    <span class="n">node</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">minimax</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">!</span><span class="n">isMax</span><span class="p">);</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">isMax</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">getScore</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">getScore</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isMax</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">getScore</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">getScore</span><span class="p">()){</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>코드 상으로는 매우 간단하다. 여기서 코드는 재귀로 돌아가면서 isMax는 매번 not 연산자로 바뀌고 있다. not을 한 이유는 이 게임은 턴제로서 상대방이 한 수를 둔 뒤 다른 사람이 또 한 수를 두기 때문이다. 그러므로 isMax가 true이라면 인공지능이 둘 차례 라는 의미이며, false이면 인공지능이 아닌, 상대방이 두는 차례 라는 의미이다. 각각 isMax에서 최소값과 최대값을 구한다. 구하면서 최종 Root 노드에서 인공지능이 이길 수 있는 최대값을 내도록 한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 다음 수를 계산 함.</span>
<span class="n">board</span> <span class="nf">nextStep</span><span class="p">(</span><span class="n">board</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 현재 상태를 기준으로 보드를 분기 함.</span>
    <span class="n">node</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">makeRootNode</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="c1">// 분기한 보드 중 최고의 수 노드를 구함.</span>
    <span class="n">node</span> <span class="n">bestNode</span> <span class="o">=</span> <span class="n">minimax</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
    
    <span class="c1">// 그리고 최고의 노드를 반환 함.</span>
    <span class="k">return</span> <span class="n">bestNode</span><span class="p">.</span><span class="n">current</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>현재 보드 상태를 기준으로 노드를 분기 하고, 분기한 노드 중 인공지능이 둘 수 있는 최고의 노드를 구한 뒤 반환을 하는 함수이다. 현재는 board 상태만 반환을 하지만 board 구조체 안에 point 라는 자료를 추가하여 착수 한 위치도 기억하게 할 수 도 있다.</p> <h1 id="알파-베타-프루닝">알파 베타 프루닝</h1> <p>여기서 현재 minimax는 모든 가능 한 수를 분기 한 뒤 최 하위에 있는 노드의 점수를 구하여 최 상위 노드에서 결과를 도출 하는 방식이다.</p> <p>하지만 해당 방식에서는 19x19 크기의 바둑판 경우에서는 매 수 마다 361개의 노드가 분기가 되므로 10번 째 후의 수를 37,589,973,457,545,958,193,355,601 개의 노드를 분기하게 되므로 매우 비효율 적이다. 그래서 A* 처럼 최고의 수가 될 가능성이 낮은 노드는 분기하지 않도록 해서 최적 해를 구하는 알고리즘이다.</p> <h1 id="개인-생각">개인 생각</h1> <p>minimax 알고리즘에 대해서 공부를 하게 되면서 다양한 알고리즘을 알게 되는 경험이 되었다. 예를 들어서 “알파-베타 프루닝” 이나 “몬테 카를로 트리 서치(MCTS)” 처럼 다양한 게임 이론에 쓰이는 인공지능을 알게 되었다. 공부를 하게 되면서 결국 나의 목표는 DQN 처럼 매번 게임을 하면서 학습을 하는 인공지능을 만든다고 했었는데 그 해결책이 MCTS 가 될 것 같은 느낌이다. MCTS는 정말 간단한 이론 이지만 안에 들어 있는 내용은 포인터와 같이 응용이 가능한 범위가 엄청 넓은 알고리즘인 것 같다.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Winograd-Algorithm/">위노그라드 알고리즘 정리</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/ssh-vpn-forward/">외부에서 내부망으로 접근하기 위한 3가지의 방법론</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/GIST-Developer/">GIST Developers' Night 2024에 연사로 참가하고 나서</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/jvm-book-readed/">JVM 밑바닥까지 파헤치기 책을 읽고</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/reading-High-Performance-Cpp/">고성능을 위한 언어 C++ 책을 읽고나서</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 JooHyoung Cha. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>