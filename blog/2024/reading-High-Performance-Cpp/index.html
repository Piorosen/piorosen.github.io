<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 고성능을 위한 언어 C++ 책을 읽고나서 | JooHyoung Cha </title> <meta name="author" content="JooHyoung Cha"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://blog.udon.party/blog/2024/reading-High-Performance-Cpp/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">JooHyoung</span> Cha </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">고성능을 위한 언어 C++ 책을 읽고나서</h1> <p class="post-meta"> Created in July 09, 2024 by piorosen </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/read"> <i class="fa-solid fa-hashtag fa-sm"></i> read</a>   <a href="/blog/tag/cpp"> <i class="fa-solid fa-hashtag fa-sm"></i> cpp</a>   <a href="/blog/tag/book"> <i class="fa-solid fa-hashtag fa-sm"></i> book</a>   <a href="/blog/tag/high"> <i class="fa-solid fa-hashtag fa-sm"></i> high</a>   <a href="/blog/tag/performance"> <i class="fa-solid fa-hashtag fa-sm"></i> performance</a>   <a href="/blog/tag/high-performance"> <i class="fa-solid fa-hashtag fa-sm"></i> high-performance</a>   ·   <a href="/blog/category/blogging"> <i class="fa-solid fa-tag fa-sm"></i> Blogging</a>   <a href="/blog/category/review"> <i class="fa-solid fa-tag fa-sm"></i> Review</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="개요">개요</h1> <p>이번에 읽은 책으로는 기존에 공부하였던 내용들에 대해서 한번 더 복습하는 기회가 되었다. 그리고 C++ 20 에 대해서 한 번 공부 할 수 있는 기회였다. 아무래도, C++ 20이나 C++ 23은 책으로된 내용이 많이 부족하다 보니 좋은 기회였다. 그렇지만 다음에 이 책을 읽을 기회가 있는 새로운 독자의 경우에는 충분한 C++ 지식이나 다른 언어에 대한 선행 지식이 있어야 읽기 편할것 같다.</p> <p>무언가 C++에 대해서 깊고 심오함을 공부하고 싶다면 <code class="language-plaintext highlighter-rouge">Optimized C++</code>를 읽어보는것이 더 좋을 것이며, 이 책의 경우에는 C++ 17과 C++ 20에서 메모리 관리와 새로운 문법에 대해서 공부에 집중한 느낌이였다.</p> <p>책의 페이지가 총 450p 정도 되는 양이였고, 하루에 100p 정도 읽어서 4일만에 다 읽었기 때문에, 충분한 사전 지식이 있다면 술술 읽을 수 있을것이라 생각한다.</p> <h1 id="핵심-내용">핵심 내용</h1> <p>필자가 재밌게 읽었던 부분을 요약하자면 아래와 같고, 이름은 필자가 조금 변형하였다.</p> <ol> <li>캡처가 된다면 람다는 클래스화가 되는거였다! p76</li> <li>이동 시멘틱은 나 천재인듯! 이제야 이해하다니!! ㅠㅠ rust의 소유권 이전과 동일하구나! p100</li> <li>평행 배열이 존재할 때, 구조체의 변수의 크기가 작다면, 캐시 라인에 많은 배열이 들어가므로, 속도 개선이 된다. p158</li> <li> <code class="language-plaintext highlighter-rouge">Iterator</code> 직접 구현해서 <code class="language-plaintext highlighter-rouge">LinearIterator</code> 만들어보기 p180</li> <li> <code class="language-plaintext highlighter-rouge">swap</code>이나 <code class="language-plaintext highlighter-rouge">std::move</code>를 사용하더라도, <code class="language-plaintext highlighter-rouge">noexcept</code>로 명시해야함. p189</li> <li> <code class="language-plaintext highlighter-rouge">std::ranges::view</code> 에는 다양한 Lazy Evaul or functional 기능이 있다 C++20, p206</li> <li> <code class="language-plaintext highlighter-rouge">std::ranges::action</code> 즉각적인 평가를 수행하고, <code class="language-plaintext highlighter-rouge">Mutable</code> 하다.</li> <li>C++ 자원관리 <code class="language-plaintext highlighter-rouge">RAII (Resource Acquisition is Initialization)</code> p239</li> <li>명시적 새로운 new 선언! 신기했다. p243</li> <li> <code class="language-plaintext highlighter-rouge">Reflection</code>을 <code class="language-plaintext highlighter-rouge">tie</code>로 구현하는 재미 310p</li> <li> <code class="language-plaintext highlighter-rouge">shared_ptr</code> 복사와 생성은 쓰레드 안전하지만, 안에 있는 데이터는 쓰레드 세이프 하지 않다. p394 + cppreference</li> </ol> <h1 id="요약">요약</h1> <ol> <li>캡처가 된다면 람다는 클래스화가 되는거였다! p76</li> </ol> <p>이것은 이전부터 설명하던 내용이여서 바로 생략을 하도록 한다.</p> <ol> <li>이동 시맨틱은 rust의 소유권 이전과 동일하다.</li> </ol> <p><code class="language-plaintext highlighter-rouge">std::move</code>나 <code class="language-plaintext highlighter-rouge">std::forward</code>에서 이 함수들은 도대체 무슨 역할을 하는지 이해하게 되었다. 정말 단순하게 생성자와 복사 행위를 멈추기 위해서, <code class="language-plaintext highlighter-rouge">auto p = std::move(var)</code>를 사용하여 <code class="language-plaintext highlighter-rouge">var</code>에 대한 접근 권한을 빼앗고, <code class="language-plaintext highlighter-rouge">p</code>에게 전달하는 것이다. 이것이 왜 필요한가에 대해서는 함수로 넘어가게 된다면 말이 달라지게 되는 것이였다.</p> <p>극히 정말로 단순하게 함수에서 구조체나 클래스가 넘어가게 될 경우 포인터나 레퍼런스 타입으로 값을 전달하지 않는다면 반드시 생성자나 복사가 발생하게 된다. 하지만 가끔 사람들이 포인터나 레퍼런스 값을 전달해준 이후에 소유권 자체를 완전히 넘겨주고 싶은 경우가 존재한다. 예시로 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>이 있으며, 단일 객체로만 존재해야하는 경우도 존재한다. 그렇기 때문에, <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>의 경우에 복사나 생성자가 호출되는 순간 2개 이상의 객체가 생성이 되므로 문제가 생기게 되고, 포인터로 넘겨지게 된다면 해당 객체를 가르키는 변수가 2개 이상이므로 문제가 생기게 된다.</p> <p>그래서 이러한 문제를 없애기 위해 <code class="language-plaintext highlighter-rouge">std::move</code>와 <code class="language-plaintext highlighter-rouge">std::forward</code>가 존재하게 되는 것 이였다. 크게 어렵게 생각할 이유가 없는것 같다.</p> <ol> <li>평행 배열이 존재할 때, 구조체의 변수의 크기가 작다면, 캐시 라인에 많은 배열이 들어가므로, 속도 개선이 된다. p158</li> </ol> <p>이 부분에 대한 내용은 정말로 신기하였으며, 당연하면서도 새로운 기분을 주는 듯한 내용이였다. 구조체의 데이터가 배열 형태로 존재하고, 구조체의 크기가 작으면 작을 수록 한번의 캐시로의 데이터 이동으로 많은 데이터를 옮길 수 있게 되므로 성능 향상에 도움이 되는 것이다.</p> <p>그렇다면 기존에 거대해진 구조체를 어떻게 성능 향상을 시킬수 있는가? 에 대한 질문으로는 포인터를 적극 활용하여 해결 할 수 있다는 것이다. 즉, 구조체 1개로 모든 데이터를 담는 것이 아닌, 구조체 3개 4개로 분할해서 만들고, 1개의 구조체에 나머지 구조체를 포인터 형태로 간접 접근 하는 방식으로 채택한다면, 하나의 캐시 라인에 최대한 많은 데이터가 모두 들어갈 수 있다.</p> <p>단점으로는, 포인터화되어서 간접적으로 접근하게 된 값은 2중 참조하여야 접근이 되므로 더 많은 성능을 요구하게 된다라는 것이 큰 단점이다. 그렇기 때문에 적절한 조절이 필요한, 그리고 최적화가 가능한 부분이라고 필자는 생각한다.</p> <ol> <li>C++ 자원관리 <code class="language-plaintext highlighter-rouge">RAII (Resource Acquisition is Initialization)</code> p239</li> </ol> <p>정말로 몰랐던 내용으로는 <code class="language-plaintext highlighter-rouge">Stack</code>과 <code class="language-plaintext highlighter-rouge">Heap</code> 메모리에 대한 정의나 실질적으로 활용되는 언어는 극히 드물다는 것을 알게 되었습니다. 대표적으로 <code class="language-plaintext highlighter-rouge">Java</code>나 <code class="language-plaintext highlighter-rouge">Python</code>의 경우에는 모든 변수들을 <code class="language-plaintext highlighter-rouge">Heap</code>에만 저장하므로 <code class="language-plaintext highlighter-rouge">Stack</code>에서는 따로 관리가 되고 있지 않다는 것을 알게 되었습니다. 물론 <code class="language-plaintext highlighter-rouge">Java</code>의 경우에는 모든 변수가 포인터 형태로 관리가 되고 있기 때문에, <code class="language-plaintext highlighter-rouge">Stack</code>을 활용하기도 하나, 대부분은 생성되는 변수는 <code class="language-plaintext highlighter-rouge">Stack</code>에는 포인터 변수가, <code class="language-plaintext highlighter-rouge">Heap</code>에는 실제 데이터가 있는 구조로 되어 있습니다.</p> <p>그래서 <code class="language-plaintext highlighter-rouge">Stack</code>에 데이터 저장과 <code class="language-plaintext highlighter-rouge">Heap</code>에 데이터를 저장을 원하는대로, 그리고 명시적으로 지정이 가능하므로 이를 활용한 자원 관리 기법이란 것이 나타났는데, 그것이 바로 <code class="language-plaintext highlighter-rouge">RAII(Resource Acquisition is Initialization)</code>입니다.</p> <p><code class="language-plaintext highlighter-rouge">GC(Garbage Collect)</code> 없는 C++ 에서는 <code class="language-plaintext highlighter-rouge">Stack</code> 메모리에서 데이터의 삭제를 시기를 기준으로 자원을 관리하는 것 입니다. 즉, 아래와 같은 코드로 자원을 관리 할 수 있습니다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//* 어딘가 Timer란 구현체가 존재함.</span>

<span class="p">{</span>
    <span class="n">ScopedTimer</span> <span class="n">t</span><span class="p">(</span><span class="s">"Something Work!"</span><span class="p">);</span>

    <span class="c1">// Do Working</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 코드를 실행하게 되었을 때, <code class="language-plaintext highlighter-rouge">t</code>란 변수가 <code class="language-plaintext highlighter-rouge">Stack</code>으로 부터 파괴가 되었을 때 실행 시간을 출력하는 기능을 만들 수 있습니다.</p> <ol> <li> <code class="language-plaintext highlighter-rouge">shared_ptr</code> 복사와 생성은 쓰레드 안전하지만, 안에 있는 데이터는 쓰레드 세이프 하지 않다.</li> </ol> <p>뭔가 처음에는 <code class="language-plaintext highlighter-rouge">shared_ptr</code>에 있는 <code class="language-plaintext highlighter-rouge">counter</code>가 <code class="language-plaintext highlighter-rouge">atomic</code>하다고 알고 있었는데, 이 말이 무슨말인지 처음에는 이해가 잘 되지 않았다. 하지만 다시 생각해보면 당연하다는 말이라는 것을 알게 되었다.</p> <p><code class="language-plaintext highlighter-rouge">shared_ptr</code>이 복사나 대입을 통해 새롭게 생성이 된다면 <code class="language-plaintext highlighter-rouge">counter</code>가 <code class="language-plaintext highlighter-rouge">atomic</code>하므로 멀티 쓰레드 환경에서 문제가 발생하지 않는다. 하지만 멀티 쓰레드 환경에서 <code class="language-plaintext highlighter-rouge">shared_ptr</code>을 사용한다면 말이 달라지게 된다 <code class="language-plaintext highlighter-rouge">shared_ptr</code>에 있는 데이터는 <code class="language-plaintext highlighter-rouge">atomic</code>한 것이 아니기 때문이다. 즉, <code class="language-plaintext highlighter-rouge">shared_ptr</code>이 가르키는 포인터는 <code class="language-plaintext highlighter-rouge">atomic</code>하지 않고, 오직 <code class="language-plaintext highlighter-rouge">counter</code>만이 <code class="language-plaintext highlighter-rouge">atomic</code>하다.</p> <p>원문으로는 아래와 같으며, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" rel="external nofollow noopener" target="_blank">[공식 문서]</a> 이다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different shared_ptr objects without additional synchronization even if these objects are copies and share ownership of the same object. If multiple threads of execution access the same shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur; the std::atomic&lt;shared_ptr&gt; can be used to prevent the data race.
</code></pre></div></div> <p>정말로 당연하면서도,,, 실수를 많이 할 것 같은 내용이였다.</p> <h1 id="결론">결론</h1> <p>일부 설명하지 않은 내용인 C++ 20에 대한 내용(<code class="language-plaintext highlighter-rouge">views</code>나 <code class="language-plaintext highlighter-rouge">action</code>), <code class="language-plaintext highlighter-rouge">Memory Arena</code>와 같은 추가적인 메모리 생성/파괴 관련 최적화(<code class="language-plaintext highlighter-rouge">new</code>, <code class="language-plaintext highlighter-rouge">delete</code>) 내용 또한 워낙에 쉽게 설명이 되어 있어서 정말로 좋았다.</p> <p>C++ 20에 대한 내용을 요약에 담지 않은 이유로는 한번 직접 읽어 보았으면 하는 느낌이 강하였으며, <code class="language-plaintext highlighter-rouge">Memory Arena</code>의 경우에는 필자가 아직도 완벽하게 이해를 못한 것 같으므로, 내용을 생략하게 되었다.</p> <p>필자가 이해한 <code class="language-plaintext highlighter-rouge">Memory Arena</code>를 간단하게 설명하자면 거대한 메모리를 사전에 생성하고 new 나 delete 직접 구현하여 Memory Allocator를 제공한다. 그리고 사전에 생성된 거대한 메모리가 부족하다면 추가적으로 <code class="language-plaintext highlighter-rouge">Heap</code>에 메모리를 할당하는 방식으로, 그냥 새로운 메모리 <code class="language-plaintext highlighter-rouge">Allocator</code>를 위한 공간을 생성하는 객체라고 생각하게 되었다.</p> <p>그렇지만… 필자가 간단하게 검색한 <code class="language-plaintext highlighter-rouge">Arena</code>는 그러한 것이 아니였으므로 조금 더 근본적인 <code class="language-plaintext highlighter-rouge">Memory Arena</code>에 대해서 공부할 예정이다.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Winograd-Algorithm/">위노그라드 알고리즘 정리</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/ssh-vpn-forward/">외부에서 내부망으로 접근하기 위한 3가지의 방법론</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/GIST-Developer/">GIST Developers' Night 2024에 연사로 참가하고 나서</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 JooHyoung Cha. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>